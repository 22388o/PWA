{"version":3,"sources":["common/Post/components/Image/index.js","utils/Cache.js","utils/Promise.js","utils/Torrents.js"],"names":["Image","id","item","index","postId","tipValue","tipCounter","hideRibbon","width","disableZoom","style","useState","zoomed","setZoomed","zoomLoaded","setZoomLoaded","previewVisible","setPreviewVisible","animationTimer","setAnimationTimer","handleZoomChange","useCallback","value","clearTimeout","timer","setTimeout","contentURL","decodeURIComponent","magnetURI","replace","mainImageStyle","opacity","imgNode","className","alt","data-torrent","data-file-key","src","onLoad","display","isZoomed","onZoomChange","overlayBgColorStart","overlayBgColorEnd","getCachedFile","fileName","a","FileCache","_init","Promise","resolve","reject","init","then","console","log","persist","status","persistent","load","cachedFile","createURL","warn","renderCachedFile","fileURL","selector","elements","document","querySelectorAll","length","forEach","element","muted","autoplay","saveFile","buffer","save","runSerial","tasks","result","task","supportedFileTypes","formats","options","_getFileType","file","extension","name","split","slice","supportedFileType","Object","entries","filter","includes","fileType","webTorrentClient","WebTorrent","attachMedia","posts","torrentMode","allowDuplicates","torrentTasks","map","post","contentItems","type","key","get","add","torrent","files","target","destroy","torrentElement","format","toLowerCase","endsWith","compatibleURL","elementSrc","getAttribute","setAttribute","renderTo","on","getBlob","err","blob","querySelector","dataset","played","reduce","torrents"],"mappings":"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","file":"static/js/17.547ccebf.chunk.js","sourcesContent":["import React, { useState, useCallback } from \"react\";\nimport { Controlled as ControlledZoom } from \"react-medium-image-zoom\";\nimport TipRibbon from \"../TipRibbon\";\nimport \"react-medium-image-zoom/dist/styles.css\";\nimport \"./css/index.scoped.css\";\n\nconst IMAGE_TRANSITION_MS = 200;\n\nconst Image = ({\n  id = \"\",\n  item,\n  index = 0,\n  postId = \"\",\n  tipValue = 0,\n  tipCounter = 0,\n  hideRibbon = false,\n  width = null,\n  disableZoom = false,\n  style = /** @type {import('react').CSSProperties} */ ({})\n}) => {\n  const [zoomed, setZoomed] = useState(false);\n  const [zoomLoaded, setZoomLoaded] = useState(false);\n  const [previewVisible, setPreviewVisible] = useState(true);\n  const [animationTimer, setAnimationTimer] = useState(null);\n\n  const handleZoomChange = useCallback(\n    value => {\n      clearTimeout(animationTimer);\n      setZoomed(value);\n      if (!value && zoomLoaded) {\n        setZoomLoaded(false);\n        const timer = setTimeout(() => {\n          setPreviewVisible(true);\n        }, IMAGE_TRANSITION_MS);\n        setAnimationTimer(timer);\n      }\n\n      if (value) {\n        setPreviewVisible(false);\n      }\n    },\n    [\n      animationTimer,\n      zoomLoaded,\n      setZoomed,\n      setZoomLoaded,\n      setPreviewVisible,\n      setAnimationTimer\n    ]\n  );\n\n  const contentURL = decodeURIComponent(\n    item.magnetURI.replace(/.*(ws=)/gi, \"\")\n  );\n  const mainImageStyle = { ...style, opacity: previewVisible ? 1 : 0 };\n  if (width) {\n    mainImageStyle.width = width;\n  }\n\n  const imgNode = (\n    <>\n      <img\n        className={`image torrent-img torrent-img-${postId}-${id}`}\n        alt=\"Post Media\"\n        data-torrent={item.magnetURI}\n        data-file-key={index}\n        style={mainImageStyle}\n        src={contentURL}\n      />\n      <img\n        className={`image enlarged-img enlarged-img-${postId}-${id}`}\n        alt=\"Post Media\"\n        data-file-key={index}\n        onLoad={() => {\n          setZoomLoaded(true);\n        }}\n        style={{\n          opacity: zoomed ? 1 : 0,\n          display: zoomed ? \"block\" : \"none\"\n        }}\n        src={contentURL}\n      />\n      {!hideRibbon && (\n        <TipRibbon\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          zoomed={zoomed}\n        />\n      )}\n    </>\n  );\n\n  return (\n    <div className=\"media-container\">\n      {disableZoom ? (\n        imgNode\n      ) : (\n        <ControlledZoom\n          isZoomed={zoomed}\n          onZoomChange={handleZoomChange}\n          overlayBgColorStart=\"#16191c00\"\n          overlayBgColorEnd=\"#16191c\"\n        >\n          {imgNode}\n        </ControlledZoom>\n      )}\n    </div>\n  );\n};\n\nexport default Image;\n","import FileCache from \"browser-file-storage\";\n\nexport const DB_NAME = \"ShockWalletStore\";\n\nexport const init = () =>\n  new Promise((resolve, reject) => {\n    FileCache.init(DB_NAME)\n      .then(() => {\n        console.log(\"File cache initialized!\");\n        return FileCache.persist();\n      })\n      .then(status => {\n        if (status.persistent) {\n          resolve(status);\n        } else {\n          reject(status);\n        }\n      });\n  });\n\nexport const getCachedFile = async fileName => {\n  try {\n    if (!FileCache._init) {\n      await init();\n    }\n\n    const cachedFile = await FileCache.load(fileName);\n    return cachedFile.createURL();\n  } catch (err) {\n    console.warn(err);\n    return false;\n  }\n};\n\nexport const renderCachedFile = (fileURL, selector) => {\n  const elements = document.querySelectorAll(selector);\n  if (elements && elements.length) {\n    elements.forEach(element => {\n      if (!element.src) {\n        element.src = fileURL;\n        element.muted = true;\n        element.autoplay = true;\n      }\n    });\n  }\n  return !!elements?.length;\n};\n\nexport const saveFile = (fileName, buffer) => {\n  return FileCache.save(fileName, buffer);\n};\n","export const runSerial = tasks => {\n  let result = Promise.resolve();\n  tasks.forEach(task => {\n    result = result.then(() => task());\n  });\n  return result;\n};\n","import WebTorrent from \"webtorrent\";\nimport { getCachedFile, renderCachedFile, saveFile } from \"./Cache\";\nimport { runSerial } from \"./Promise\";\n\nconst supportedFileTypes = {\n  \"video/embedded\": {\n    formats: [\"mp4\", \"webm\"],\n    element: \"video\",\n    options: {\n      autoplay: true,\n      muted: true\n    }\n  },\n  \"image/embedded\": {\n    formats: [\"jpg\", \"png\", \"webp\", \"jpeg\"],\n    element: \"img\",\n    options: {}\n  }\n};\n\nconst _getFileType = file => {\n  const extension = file.name?.split(\".\")?.slice(-1)[0];\n  const supportedFileType = Object.entries(\n    supportedFileTypes\n  ).filter(([type, options]) => options.formats.includes(extension))[0];\n\n  if (supportedFileType) {\n    const [name, fileType] = supportedFileType;\n    return {\n      name,\n      ...fileType\n    };\n  }\n\n  return null;\n};\n\nexport const webTorrentClient = new WebTorrent();\n\nexport const attachMedia = (\n  posts = [],\n  torrentMode = true,\n  allowDuplicates = false\n) => {\n  const torrentTasks = posts\n    .map(post => {\n      const { contentItems, id } = post;\n      return Object.entries(contentItems ?? {})\n        .filter(([key, item]) => supportedFileTypes[item.type])\n        .map(([key, item]) => () =>\n          new Promise(resolve => {\n            const torrentExists = webTorrentClient.get(item.magnetURI);\n\n            if (torrentExists && !allowDuplicates) {\n              resolve(true);\n              return;\n            }\n\n            webTorrentClient.add(item.magnetURI, async torrent => {\n              // Proceed to the next torrent in queue\n              resolve(true);\n\n              const files = torrent.files.filter(file => {\n                const extension = file.name?.split(\".\")?.slice(-1)[0];\n                const supportedFileType = Object.entries(\n                  supportedFileTypes\n                ).filter(([type, options]) =>\n                  options.formats.includes(extension)\n                )[0];\n                if (supportedFileType) {\n                  const [, fileType] = supportedFileType;\n                  const matched = fileType.formats.includes(extension);\n                  return matched;\n                }\n                return false;\n              });\n\n              files.map(async file => {\n                const fileType = _getFileType(file);\n\n                if (!fileType) {\n                  return;\n                }\n\n                const fileName = `${id}-${key}-${file.name}`;\n\n                const element = fileType.element;\n                const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n                const cachedFile = await getCachedFile(fileName);\n\n                if (cachedFile) {\n                  const torrent = webTorrentClient.get(item.magnetURI);\n\n                  if (torrent) {\n                    torrent.destroy();\n                  }\n\n                  renderCachedFile(cachedFile, target);\n                  return;\n                }\n\n                const torrentElements = document.querySelectorAll(target);\n                torrentElements.forEach(torrentElement => {\n                  const contentURL = decodeURIComponent(\n                    item.magnetURI.replace(/.*(ws=)/gi, \"\")\n                  );\n                  const [compatibleURL] = fileType.formats.filter(format =>\n                    contentURL\n                      .toLowerCase()\n                      .endsWith(`.${format.toLowerCase()}`)\n                  );\n                  const elementSrc = torrentElement.getAttribute(\"src\");\n\n                  if ((torrentMode || !compatibleURL) && !elementSrc) {\n                    file.renderTo(torrentElement, fileType.options);\n                    return;\n                  }\n\n                  torrentElement.setAttribute(\"src\", contentURL);\n                });\n              });\n\n              torrent.on(\"done\", () => {\n                files.map(file => {\n                  const fileType = _getFileType(file);\n                  const fileName = `${id}-${key}-${file.name}`;\n                  const element = fileType.element;\n                  const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n\n                  file.getBlob(async (err, blob) => {\n                    if (err) {\n                      console.warn(err);\n                      return;\n                    }\n\n                    await saveFile(fileName, blob);\n                    const element = document.querySelector(target);\n                    if (\n                      element?.dataset.played === \"false\" &&\n                      !element?.getAttribute(\"src\")\n                    ) {\n                      const cachedFile = await getCachedFile(fileName);\n                      renderCachedFile(cachedFile, target);\n                    }\n                  });\n\n                  return file;\n                });\n              });\n            });\n          })\n        );\n    })\n    .reduce((torrents, contentItems) => [...torrents, ...contentItems], []);\n\n  runSerial(torrentTasks);\n};\n"],"sourceRoot":""}