{"version":3,"sources":["../node_modules/react-cool-inview/dist/index.esm.js","../node_modules/lodash/sum.js","vanilla/components/alignment.ts","vanilla/components/utils.ts","vanilla/components/counter.ts","vanilla/components/eventStore.ts","vanilla/components/vector1d.ts","vanilla/components/dragHandler.ts","vanilla/components/limit.ts","vanilla/components/scrollBody.ts","vanilla/components/scrollBounds.ts","vanilla/components/scrollContain.ts","vanilla/components/scrollLooper.ts","vanilla/components/scrollProgress.ts","vanilla/components/scrollSnap.ts","vanilla/components/scrollTarget.ts","vanilla/components/slideLooper.ts","vanilla/components/slideFocus.ts","vanilla/components/translate.ts","vanilla/components/engine.ts","vanilla/components/pxToPercent.ts","vanilla/components/direction.ts","vanilla/components/axis.ts","vanilla/components/slideSizes.ts","vanilla/components/scrollLimit.ts","vanilla/components/animation.ts","vanilla/components/scrollTo.ts","vanilla/components/slidesInView.ts","vanilla/components/dragTracker.ts","vanilla/components/options.ts","vanilla/index.ts","vanilla/components/eventEmitter.ts","vanilla/components/optionsPseudo.ts","react/index.ts","react/utils.ts","../node_modules/lodash/_baseSum.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","useLatest","val","ref","useRef","current","useInView","_temp","_ref","root","rootMargin","_ref$threshold","threshold","trackVisibility","delay","unobserveOnEnter","onChange","onEnter","onLeave","_useState","useState","inView","scrollDirection","state","setState","prevInViewRef","prevPosRef","observerRef","warnedRef","onChangeRef","onEnterRef","onLeaveRef","unobserve","useCallback","disconnect","observe","element","updatePosition","_ref$current$getBound","getBoundingClientRect","x","y","useEffect","window","IntersectionObserver","_ref2","entry","intersectionRatio","isIntersecting","_entry$boundingClient","boundingClientRect","isVisible","min","Array","isArray","Math","undefined","horizontal","vertical","e","console","warn","error","JSON","stringify","baseSum","require","identity","module","exports","array","Alignment","align","viewSize","predefined","start","center","end","measure","Number","mathSign","n","deltaAbs","valueB","valueA","groupArray","size","groups","arrayKeys","arrayLast","lastIndex","removeClass","node","className","cl","addClass","Counter","limit","loop","max","withinLimit","counter","self","add","sign","set","get","clone","EventStore","listeners","options","removeAll","remove","Vector1D","value","vector","readNumber","divide","multiply","normalize","subtract","DragHandler","axis","direction","rootNode","dragFree","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","index","events","scrollAxis","scroll","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","pointerIsDown","preventScroll","preventClick","isMouse","evt","isMoving","clearPreventClick","isNotFocusNode","name","isFocusNode","preventDefault","addInteractionEvents","up","moveScroll","moveCross","diffScroll","diffCross","diff","rawForce","force","seekNext","currentLocation","destination","next","allowedForce","speedFactor","factorAbs","addActivationEvents","clickAllowed","pointerDown","removeAllEvents","Limit","reachedMin","reachedMax","constrain","reachedAny","removeOffset","ScrollBody","baseMass","roundToTwoDecimals","decimalPoints","pow","roundToDecimals","velocity","acceleration","attraction","attractionDirection","speed","mass","seek","iStart","oStart","magnitude","v","applyForce","settle","hasSettled","update","useBaseMass","useMass","useBaseSpeed","useSpeed","ScrollBounds","disabled","shouldConstrain","friction","diffToTarget","toggleActive","ScrollContain","contentSize","snaps","snapsAligned","containScroll","scrollBounds","snapsBounded","snapsContained","startSnap","endSnap","findDuplicates","measureContained","ScrollLooper","pxToPercent","shouldLoop","loopDistance","vectors","ScrollProgress","scrollLength","ScrollSnap","alignment","containerRect","slideRects","slidesToScroll","startEdge","endEdge","rect","groupedSnaps","g","alignments","rects","measureSizes","snap","measureAligned","ScrollTarget","indexCurrent","scrollSnaps","targetVector","t1","t2","t3","minDistance","shortest","byDistance","targetSnap","distance","scrollSnap","shortcut","diffToSnap","d1","d2","ascDiffsToSnaps","findTargetSnap","findTargetIndex","reachedBound","byIndex","SlideLooper","slideSizesWithGaps","slidesInView","scrollLocation","ascItems","descItems","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","indexes","a","removeSlideSizes","remainingGap","isStartEdge","edge","offset","slideBounds","initial","altered","point","b","getTarget","canLoop","clear","slides","loopPoint","SlideFocus","eventStore","lastTabPressTime","event","Date","selectedIndex","Translate","container","containerStyle","translate","to","Engine","viewInPx","contentDirection","startIndex","inViewThreshold","slide","applyTo","Direction","cross","measureSize","width","height","Axis","totalPercent","sizesInPx","slideSizes","isLast","style","endGap","parseFloat","SlideSizes","measureLimit","ScrollLimit","indexPrevious","slideIndexes","callback","animationFrame","active","cb","proceed","ifAnimating","stop","Animation","engine","settled","startLocation","loopVectors","distanceDiff","indexDiff","targetIndex","ScrollTo","findSlideBounds","thresholds","s","check","slideBound","list","SlidesInView","dragHandler","coords","startDrag","diffDrag","lastDrag","pointValue","trackPoints","lastMoveTime","c","readPoint","pointerMove","nowTime","diffTime","pointerUp","currentPoint","DragTracker","scrollLooper","scrollProgress","slideFocus","slideLooper","defaultOptions","draggable","draggableClass","draggingClass","selectedClass","EmblaCarousel","emit","getListeners","off","on","EventEmitter","debouncedResize","time","timeout","debounce","sliderRoot","rootNodeSize","reActivate","reInit","activated","Error","sliderContainer","optionsPseudo","psuedoString","OptionsPseudo","setupElements","deActivate","activate","toggleSelectedClass","setTimeout","slidesNotInView","notInView","newOptions","selectedScrollSnap","type","canScrollNext","canScrollPrev","prev","containerNode","dangerouslyGetEngine","destroy","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes","embla","setEmbla","viewport","setViewport","storedOptions","activeOptions","useMemo","objectA","objectB","newEmbla_1","iteratee","result"],"mappings":"oHAAA,WAEA,SAASA,IAeP,OAdAA,EAAWC,OAAOC,QAAU,SAAUC,GACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CACzC,IAAIG,EAASF,UAAUD,GAEvB,IAAK,IAAII,KAAOD,EACVN,OAAOQ,UAAUC,eAAeC,KAAKJ,EAAQC,KAC/CL,EAAOK,GAAOD,EAAOC,IAK3B,OAAOL,IAGOS,MAAMC,KAAMR,WAG9B,IAAIS,EAAa,SAAUC,GACzB,IAAIC,EAAMC,iBAAOF,GAEjB,OADAC,EAAIE,QAAUH,EACPC,GA8IMG,IAxIC,SAAmBC,GACjC,IAAIC,OAAiB,IAAVD,EAAmB,GAAKA,EAC/BE,EAAOD,EAAKC,KACZC,EAAaF,EAAKE,WAClBC,EAAiBH,EAAKI,UACtBA,OAA+B,IAAnBD,EAA4B,EAAIA,EAC5CE,EAAkBL,EAAKK,gBACvBC,EAAQN,EAAKM,MACbC,EAAmBP,EAAKO,iBACxBC,EAAWR,EAAKQ,SAChBC,EAAUT,EAAKS,QACfC,EAAUV,EAAKU,QAEfC,EAAYC,mBAAS,CACvBC,QAAQ,EACRC,gBAAiB,KAEfC,EAAQJ,EAAU,GAClBK,EAAWL,EAAU,GAErBM,EAAgBrB,kBAAO,GACvBsB,EAAatB,iBAAO,IACpBuB,EAAcvB,mBACdwB,EAAYxB,kBAAO,GACnByB,EAAc5B,EAAUe,GACxBc,EAAa7B,EAAUgB,GACvBc,EAAa9B,EAAUiB,GACvBf,EAAMC,mBACN4B,EAAYC,uBAAY,WACtBN,EAAYtB,UACdsB,EAAYtB,QAAQ6B,aACpBR,EAAWrB,QAAU,MAEtB,IACC8B,EAAUF,uBAAY,SAAUG,GAC9BA,GAAWA,IAAYjC,EAAIE,UAC7B2B,IACA7B,EAAIE,QAAU+B,GAGZT,EAAYtB,SAAWF,EAAIE,SAASsB,EAAYtB,QAAQ8B,QAAQhC,EAAIE,WACvE,CAAC2B,IACAK,EAAiBJ,uBAAY,WAC/B,GAAK9B,EAAIE,QAAT,CAEA,IAAIiC,EAAwBnC,EAAIE,QAAQkC,wBACpCC,EAAIF,EAAsBE,EAC1BC,EAAIH,EAAsBG,EAE9Bf,EAAWrB,QAAU,CACnBmC,EAAGA,EACHC,EAAGA,MAEJ,CAACtC,IA4EJ,OA3EAuC,qBAAU,WACR,MAAM,yBAA0BC,QAAa,8BAA+BA,QAQ5EhB,EAAYtB,QAAU,IAAIuC,sBAAqB,SAAUC,GACvD,IAAIC,EAAQD,EAAM,GACdE,EAAoBD,EAAMC,kBAC1BC,EAAiBF,EAAME,eACvBC,EAAwBH,EAAMI,mBAC9BV,EAAIS,EAAsBT,EAC1BC,EAAIQ,EAAsBR,EAC1BU,EAAYL,EAAMK,UAClB7B,EAAkB,GAClB8B,EAAMC,MAAMC,QAAQ1C,GAAa2C,KAAKH,IAAIrD,MAAMwD,KAAM3C,GAAaA,EACnES,OAA4BmC,IAAnBR,EAA+BA,EAAiBD,EAAoB,EACjF1B,EAAS+B,EAAM,EAAIL,GAAqBK,EAAM/B,EAE1CmB,EAAId,EAAWrB,QAAQmC,IAAGlB,EAAgBmC,WAAa,QAEvDjB,EAAId,EAAWrB,QAAQmC,IAAGlB,EAAgBmC,WAAa,SAC3D/B,EAAWrB,QAAQmC,EAAIA,EAEnBC,EAAIf,EAAWrB,QAAQoC,IAAGnB,EAAgBoC,SAAW,MAErDjB,EAAIf,EAAWrB,QAAQoC,IAAGnB,EAAgBoC,SAAW,QACzDhC,EAAWrB,QAAQoC,EAAIA,EACvB,IAAIkB,EAAI,CACNb,MAAOA,EACPxB,gBAAiBA,EACjBa,QAASA,EACTH,UAAWA,GAGTnB,SACgB2C,IAAdL,GAA4BvB,EAAUvB,UACxCuD,QAAQC,KAhGC,iHAiGTjC,EAAUvB,SAAU,QAGJmD,IAAdL,IAAyB9B,EAAS8B,IAGpC9B,IAAWI,EAAcpB,UACvBU,GAAkBiB,IAClBF,EAAWzB,SAASyB,EAAWzB,QAAQsD,KAGxCtC,GAAUI,EAAcpB,SAAW0B,EAAW1B,SAAS0B,EAAW1B,QAAQsD,GAC3E9B,EAAYxB,SAASwB,EAAYxB,QAAQlB,EAAS,GAAIwE,EAAG,CAC3DtC,OAAQA,KAEVG,EAAS,CACPH,OAAQA,EACRC,gBAAiBA,EACjBwB,MAAOA,IAETrB,EAAcpB,QAAUgB,IACvB,CACDZ,KAAMA,EACNC,WAAYA,EACZE,UAAWA,EACXC,gBAAiBA,EACjBC,MAAOA,IAETqB,IACO,WACL,OAAOH,OArEP4B,QAAQE,MA3DI,6LA4DL,WACL,OAAO,SAqEV,CAAC/C,EAAkBN,EAAMC,EAC5BqD,KAAKC,UAAUpD,GAAYC,EAAiBC,EAAOqB,EAASH,IACrD7C,EAAS,GAAIoC,EAAO,CACzBY,QAASA,EACTH,UAAWA,EACXK,eAAgBA,M,oBCjKpB,IAAI4B,EAAUC,EAAQ,KAClBC,EAAWD,EAAQ,KAsBvBE,EAAOC,QANP,SAAaC,GACX,OAAQA,GAASA,EAAM7E,OACnBwE,EAAQK,EAAOH,GACf,I,qTCdUI,EACdC,EACAC,GAEA,IAAMC,EAAa,CAAEC,MAErB,WACE,UAH0BC,OAM5B,YACE,OAAOC,KAAP,GAPkCA,IAAG,GAUvC,cACE,OAAOJ,EAAP,EAeF,MAH4B,CAC1BK,QANF,YACE,wBAAWN,EAJJC,EAAWM,OAAlB,GAKOL,KAAP,K,SCpBYM,EAASC,GACvB,OAAQA,EAAQA,EAAI1B,SAApB,GAAY,E,SAGE2B,EAASC,EAAgBC,GACvC,OAAO7B,SAAS4B,EAAhB,G,SAuBcE,EACdf,EACAgB,GAGA,IADA,IAAMC,EAAN,GACShG,EAAT,EAAgBA,EAAI+E,EAApB,OAAkC/E,GAAlC,EACEgG,OAAYjB,UAAe/E,EAA3BgG,IAEF,S,SAGcC,EAAuBlB,GACrC,OAAOlF,mBAAP,Q,SAGcqG,EAAuBnB,GACrC,OAAOA,EAAMoB,EAAb,I,SAGcA,EAAuBpB,GACrC,OAAOf,WAAYe,SAAnB,G,SAGcqB,EAAYC,EAAmBC,GAC7C,IAAMC,EAAKF,EAAX,UACIC,GAAaC,WAAjB,IAAyCA,Y,SAG3BC,EAASH,EAAmBC,GAC1C,IAAMC,EAAKF,EAAX,UACIC,IAAcC,WAAlB,IAA0CA,S,SCxD5BE,EACdC,EACAC,EACAvB,GAEQ,IAAAvB,EAAa6C,EAAb7C,IAAK+C,EAAQF,EAAb,IAEFG,EAAcH,EADPC,EAAO,OAApB,aAEIG,EAAUD,EAAd,GAEA,aACE,SAGF,cAEE,OADAC,EAAUD,EAAVC,GACA,EAgBF,IAAMC,EAAoB,CACxBC,IAdF,cACE,OAAItB,EAAS,CACX,IAAMuB,EAAOxB,EAAb,GAEA,OADAyB,EAAIC,IAAJD,GACOF,EAAItB,GAAX,EAAeuB,GAEjB,UASAG,MANF,WACE,OAAOX,EAAQC,EAAOC,EAAMQ,MAM5BA,IAHwB,EAIxBP,IAJwB,EAKxB/C,IALwB,EAMxBqD,IAAG,GAEL,S,SCtCcG,IACd,IAAIC,EAAJ,GAoBA,IAAMP,EAAuB,CAC3BC,IAnBF,kBAUE,YANA,IAAAO,OAAA,GAEAlB,0BACAiB,QAAe,WACb,OAAOjB,0BAAP,MAEF,GAUAmB,UAPF,WAEE,OADAF,EAAYA,EAAA,QAAiB,YAAY,OAAAG,OACzC,IAOF,S,SC7BcC,EAASC,GACvB,IAAIC,EAAJ,EA0BA,cAEE,OADAA,KACA,EAQF,cACE,MAAoB,kBAANlC,EAAiBA,EAAIA,EAAnC,MAGF,IAAMqB,EAAqB,CACzBC,IA9BF,YAEE,OADAY,GAAUC,EAAVD,GACA,GA6BAE,OAFyB,EAGzBX,IAzCF,WACE,UAyCAY,SAvBF,YAEE,OADAH,KACA,GAsBAI,UAdF,WAEE,OADA,IAAIJ,GAAcE,KAClB,GAaAZ,IAxCF,YAEE,OADAU,EAASC,EAATD,GACA,GAuCAK,SA/BF,YAEE,OADAL,GAAUC,EAAVD,GACA,IA+BF,S,SCvCcM,EACdC,EACAC,EACAC,EACAtI,EACAuI,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAnC,EACAoC,GAEQ,IAAQC,EAAiCZ,EAAzCa,OAA2BC,EAAcd,EAAzC,MACFe,EAAa,CAAC,QAAS,SAA7B,YACMC,EAAczB,EAApB,GACM0B,EAAa1B,EAAnB,GACM2B,EAAiB3B,EAAvB,GACM4B,EAAmBjC,IACnBkC,EAAoBlC,IACpBmC,EAAiB,CAAEC,MAAF,IAAcC,MAAO,KACtCC,EAAiB,CAAEF,MAAF,EAAYC,MAAO,GACpCE,EAAYtB,EAAW,EAA7B,GAGIuB,GAAJ,EACIC,GAAJ,EACIC,GAAJ,EACIC,GAAJ,EAoDA,cAEE,KADAA,gBAAUC,SACV,IAAgBA,SAAhB,CAEA,IAAMC,EAAWvE,EAAS5F,EAAD,MAAeyI,EAAvB7C,QAAjB,EACMwE,EAAoBH,IAA1B,EACMI,GA9BR,YACE,IAAMC,EAAOhE,YAAb,GACA,OAAO6C,cAAP,EA4BwBoB,CAAYL,EAApC,QACMM,EAAiBL,GAAaF,GAApC,EAEAH,KACAtB,iBACAc,SACAtJ,SACA4I,6BAnDF,WACE,IAAMtC,EAAQ2D,EAAd,SAAwB3B,EACxBkB,mFAkDAiB,GACArB,MAAgBZ,cAAhBY,IACAC,MAAeb,cAAfa,IACAN,sBAEA,IAAuBiB,MACvB,GAAoBE,oBAGtB,cACE,IAAKH,IAAL,EAAgC,CAC9B,IAAKG,EAAL,WAAqB,OAAOQ,IAC5B,IAAMC,EAAanC,iBAAnB,MACMoC,EAAYpC,iBAAlB,MACMqC,EAAajF,EAAS+E,EAAYvB,EAAxC,OACM0B,EAAYlF,EAASgF,EAAWvB,EAAtC,OAEA,KADAU,EAAgBc,EAAhBd,KACA,EAAqC,OAAOW,IAE9C,IAAMK,EAAOvC,cAAb,IACKwB,GAAL,IAA2BA,MAC3BtB,UACA1I,MAAWqI,UAAXrI,IACAkK,mBAGF,aACE,IAAMc,EAAWxC,eA3DHD,EAAWqB,EAAzB,GACaK,EAAU,QAAvB,SA2DMgB,EAvDR,YACE,IAEMC,IAFkBrC,gBAAxB,GACsBsC,QAA0BrC,EAAhD,QACmC7E,YA/CrC,EAgDQmH,EAAcH,EAAQxC,EAA5B,MAEA,GAAIyC,QAA0BvE,aAA9B,GAA6D,CAC3D,IAAM0E,EAAOvC,eAAb,EAA+BpD,MAC/B,OAAOmD,UAAqBwC,EAArBxC,SAAP,SAEF,OAAOA,mBAAP,SA6CcyC,CAAajD,UAA3B,IACMkD,E,SJjIgB1F,EAAgBC,GACxC,GAAID,OAAJ,IAAoBC,EAAc,OAAO,EACzC,GAAI7B,aAAoBA,SAAxB,GAA0C,OAAO,EACjD,IAAM8G,EAAOnF,EAAS3B,SAAD,GAAmBA,SAAxC,IACA,OAAOA,SAAS8G,EAAhB,GI6HsBS,CAAUR,EAA9B,GACiBpF,EAAS5F,EAAD,MAAesJ,EAAvB1D,QAAjB,KAEA,IAA0BoE,MAC1BD,KACAD,KACAN,cACAZ,WAAoBiB,EAAYA,EAAhCjB,GACAD,iBACAsB,KACAlB,oBAGF,cACE,GAAkBmB,mBAiBpB,MAN8B,CAC5BuB,oBAvHF,WACE,IAAMnF,EAAN,EACAiD,qBAC0B,eAD1BA,kBAEyB,eAFzBA,2GAsHAmC,aAVF,WACE,UAUAC,YAPF,WACE,UAOAC,gBArGF,WACErC,cACAC,gB,SCjEYqC,EAAM/H,EAAa+C,GACjC,IAAM1G,EAAS8D,SAASH,EAAxB,GAEA,cACE,OAAO6B,EAAP,EAGF,cACE,OAAOA,EAAP,EAGF,cACE,OAAOmG,MAAiBC,EAAxB,GA+BF,MAXwB,CACtBC,UANF,YACE,OAAKC,EAAL,GACOH,OAAP,EAD2BnG,GAM3BxF,OAFsB,EAGtByG,KAbF,YACE,OAAKqF,EAAL,GACOH,OAAP,EAD2BnG,GAa3BkB,IAJsB,EAKtB/C,IALsB,EAMtBmI,WANsB,EAOtBF,WAPsB,EAQtBD,WARsB,EAStBI,aA1BF,YACE,GAAIpI,IAAJ,EAAiB,OAAO6B,EACxB,KAAOmG,EAAP,IAAsBnG,KACtB,KAAOoG,EAAP,IAAsBpG,KACtB,W,SCjBYwG,EACd1D,EACAoB,EACAuC,GAEA,IAAMC,E,SNMwBC,GAC9B,IAAMC,EAAMtI,YAAZ,GACA,OAAO,YAAuB,OAAAA,KAAA,MAAW0B,EAAX,MMRH6G,CAA3B,GACMC,EAAW9E,EAAjB,GACM+E,EAAe/E,EAArB,GACMgF,EAAahF,EAAnB,GAEIiF,EAAJ,EACIC,EAAJ,EACIC,EAAJ,EAyCA,cAEE,OADAD,IACA,EAGF,cAEE,OADAC,IACA,EAGF,IAAM9F,EAAuB,CAC3BqB,UAvBF,WACE,UAuBA0E,KAxCF,YACEJ,qBACA,INxCF/E,EACAoF,EAEAC,EMqCQC,GNxCRtF,EMwCwB+E,EAAD,ONrCvBM,EMqCuB,INlCcrF,GALrCoF,EMuCuB,SNlCvB,IMkCE,ENlCc,IMsCd,OAHAJ,EAAsBlH,EAASiH,EAA/BC,OACAD,sCATF,YACEQ,YACAT,SAQAU,IACA,GAmCAC,OAhCF,YACE,IAAMtC,EAAOoC,QAAU1E,EAAvB,MACM6E,GAAcjB,EAApB,GAEA,OADA,GAAgB5D,SAChB,GA6BA8E,OArDF,WACEd,SACAhE,SACAiE,eAmDAc,YAnBF,WACE,OAAOC,EAAP,IAmBAC,aAxBF,WACE,OAAOC,EAAP,IAwBAF,QAP2B,EAQ3BE,SAAQ,GAEV,S,SC9EcC,EACdjH,EACA8B,EACAG,GAEA,IACIiF,GAAJ,EA8BA,MAJ+B,CAC7B7B,UAlBF,cACE,GARF,YACE,YACKrF,aAAiB3G,EAAtB,UACK2G,aAAiB8B,EAAtB,OAKKqF,CAAL,IACA,IAAMC,EAAWpC,EAAc,GAA/B,GACMqC,EAAehO,QAAeyI,EAApC,MAEAzI,WAAgBgO,EAAhBhO,IAEK2L,GAAe1H,YAjBtB,KAkBIjE,MAAW2G,YAAgB3G,EAA3BA,QACA4I,6BAUFqF,aANF,YACEJ,O,SC7BYK,EACd/I,EACAgJ,EACAC,EACAC,EACAC,GAEA,IAAMC,EAAe1C,GAAOsC,EAAF,EAA0BC,EAApD,IACMI,EAAeH,MAAiBE,EAAtC,WAqBA,MAHgC,CAC9BE,eARF,WACE,GAAIN,GAAJ,EAA6B,MAAO,CAACI,EAAR,KAC7B,iBAAID,EAA+B,OAAOE,EACpC,MAXR,WACE,IAAME,EAAYF,EAAlB,GACMG,EAAUxI,EAAhB,GACMrC,EAAM0K,cAAZ,GACM3H,EAAM2H,aAAZ,EACA,OAAO3C,EAAM/H,EAAb,GAMqB8K,GAAb9K,EAAG,EAAL,IAAO+C,EAAG,EAAV,IACN,OAAO2H,UAAP,GAdqBK,I,SCVTC,EACdX,EACAY,EACApI,EACA8B,GAEA,IAEM,EAA6BoD,EAFvBlF,MAAYoI,UAAxB,IACYpI,MAAYoI,UAAxB,KACQjD,EAAU,EAAZ,WAAcC,EAAU,EAAxB,WAkBN,MAH+B,CAC7BnF,KARF,cACE,GAPF,YACE,WAAIyB,EAAwB0D,EAAWtD,EAAlB,QACrB,IAAIJ,GAAyByD,EAAWrD,EAAlB,OAKjBuG,CAAL,IAEA,IAAMC,EAAed,IAArB,EAAoC9F,GACpC6G,WAAgB,YAAO,OAAA/B,EAAA,a,SCtBXgC,EAAexI,GACrB,IAAAE,EAA8BF,EAA9BE,IAAauI,EAAiBzI,EAA9B,OAUR,MAHiC,CAC/BS,IANF,YAEE,OADwBzB,EAAxB,IACA,I,SCDY0J,EACdjH,EACAkH,EACAP,EACAQ,EACAC,EACAC,GAEQ,IAAAC,EAAuBtH,EAAvBsH,UAAWC,EAAYvH,EAAvB,QACFgG,EAWGoB,EAAA,KACA,YAAU,OAAAD,EAAA,GAA2BK,EAA3B,MADV,IAEAb,EAFA,cAGA,YAAU,OAAC9K,SAAD,MAbboK,EAgBN,WACE,IAAMwB,EAAe9J,EAAWqI,EAAX,QAAsC,YAAO,OAAA0B,EAAA,MAC5DC,EAfChK,EAAWyJ,EAAX,QACA,YAAW,OAAArJ,EAAA,MAA4B6J,KAA5B,MADX,IAEAjB,EAFA,aAGA9K,KAHP,KAemBgM,IAAmBX,EAAtC,SACA,OAAOO,EAAA,KAAiB,cAAiB,OAAAK,EAAOH,EAAP,MAnBtBI,GA0BrB,MAJ6B,CAC3B/B,MAD2B,EAE3BC,aAAY,G,SC7BA+B,EACdC,EACAzJ,EACA0J,EACAnC,EACAxH,EACA4J,GAEQ,IAAAxE,EAAyCpF,EAAzCoF,WAAYE,EAA6BtF,EAAzC,WAAwBuF,EAAiBvF,EAAzC,aAER,gBACE,OAAO1C,YAAeA,SAAfA,KAAP,EAeF,gBACE,IAAMuM,EAAN,EACMC,EAAKzQ,EAAX,EACM0Q,EAAK1Q,EAAX,EAEA,MAAW,OAAOwQ,EAClB,MAAgB,OAAOG,EAAYA,EAAYH,EAAb,GAAlB,GAEhB,IAAMI,EAAWD,EAAYH,EAAInI,QAAjC,GACA,OAAOpE,YAAP,EAoCF,MAL+B,CAC7B4M,WAfF,cACE,IAAM7Q,EAASuQ,QAAf,EACMO,EAxCR,YACE,IAAMC,EAAW7E,EAAjB,GAQA,MAAO,CAAEpD,MAPewH,EAAA,KACjB,YAAgB,OAAAU,EAAA,KADC,KAEjB,YAAgB,OAAAC,EAASC,EAAT,MAFC,KAGjB,cAAa,MAAC,CAAEnG,KAAF,EAAQjC,MAAO7I,MAHZ,MAIhB,cAAY,OAAAgE,KAAA,IAASkN,EAAT,MAAoBlN,SAASmN,EAA7B,SAEFC,GAAVvI,MACQiI,SAAQ,GA+BLO,CAAnB,GACMxI,EAjBR,cAEE,GADsBlC,IAAQqF,EAA9B,GACmB,OAAOnD,EAElB,IAAAhF,EAAauM,EAAbvM,IAAK+C,EAAQwJ,EAAb,IACR,OAAOtE,OAAP,EAYcwF,CAAgBvR,EAAQ8Q,EAAtC,OACMU,GAAgB5K,GAAQqF,EAA9B,GAEA,OAAKiE,GAAL,EAAkC,CAAEpH,MAAF,EAASiI,SAAQ,GAK5C,CAAEjI,MAAF,EAASiI,SAFKA,EAAWE,EADbX,KAAqBQ,EAAxC,SACA,KAOAW,QAtBF,cAGE,MAAO,CAAE3I,MAAF,EAASiI,SADCE,EADEX,KAAqBC,EAAxC,MACA,KAqBAU,SAAQ,G,SC/DIS,EACdtJ,EACAjD,EACAgJ,EACAwD,EACArB,EACAsB,EACAC,GAEA,IAAMC,EAAW5L,EAAjB,GACM6L,EAAY7L,KAAlB,UACM8L,EAkCN,WACE,IAAMC,EAAM3B,KAAZ,EAEA,OAAO4B,EADSC,EAAYJ,EAA5B,GACA,OArCiBK,UAwCnB,WACE,IAAMH,EAAM9M,EAAWmL,EAAXnL,GAAZ,EAEA,OAAO+M,EADSC,EAAYL,EAA5B,GACA,SA3CsCO,IAExC,gBACE,OAAOC,EAAA,QAAe,cACpB,OAAOC,EAAIZ,EAAX,KADF,GAKF,gBACE,OAAOW,EAAA,QAAe,cAEpB,OADqBE,EAAiBD,EAAtC,GACOE,EAAmBF,SAAS,CAA5BE,IAAP,IAFF,IAMF,gBAIE,IAAMC,EAAN,UAAoBC,EACdC,EAASF,GAAW,EAA1B,EACMG,EAAcjB,kBAApB,GAEA,OAAOU,EAAA,KAAY,YACjB,IAAMQ,EAAUJ,EAAc,GAA9B,EACMK,EAAUL,EAAcvE,EAA9B,EAEM6E,EADSH,EAAA,QAAmB,YAAO,OAAAI,EAAA,aAAzC,GACqBP,EAAc,MAAnC,SAGA,MAAO,CAAEM,MAAF,EAASE,UAFE,WAChB,OAAArB,EAAA,aACyB/I,MAApB,EAA2BL,UAAW,MA8CjD,MAN8B,CAC5B0K,QAzBF,WACE,OAAOnB,EAAA,OAAiB,Y,IAAGlJ,EAAK,QAE9B,OAAO0J,EADcV,EAAA,QAAgB,YAAO,OAAA7R,IAAA,KACrCuS,IAAP,MAuBFY,MARF,YACEpB,WAAmB,Y,IAAGlJ,EAAK,QACzBuK,WAAoBjL,EAApBiL,kBAOFzM,KApBF,YACEoL,WAAmB,YACT,IAAAkB,EAA+BI,EAA/BJ,UAAWzK,EAAoB6K,EAA/B,SAAqBxK,EAAUwK,EAA/B,MACFtT,EAASkT,IACXlT,IAAJ,IACEqT,WAAoBjL,EAApBiL,WAAyCrT,EAAzCqT,IACAC,kBAeJtB,WAAU,G,SClGEuB,EACdjL,EACAK,EACA8G,GAEA,IAAM+D,EAAalM,IACbsE,EAAkB4H,EAAxB,UACIC,EAAJ,EAEA,cACE,IAAKC,YACLD,GAAmB,IAAIE,MAAvBF,WAGF,gBAUED,iBATc,WAGZ,MAFgB,IAAIG,MAApB,UACA,EACA,KAEArL,eACA,IAAMsL,EAAgB3P,WAAW6E,EAAjC,GACAH,iBAEF6K,GAYF,MAJ6B,CAC3B/H,oBANF,YACE+H,+BACAH,cAKAzH,gBAAe,G,SChCHiI,EACdzL,EACAC,EACAyL,GAEA,IAAMC,EAAiBD,EAAvB,MACME,EAAY5L,eAGlB,YACE,MAAO,iBAAP,cAGF,YACE,MAAO,qBAAP,UAPEyF,GAAJ,EA4BA,MAL4B,CAC1BuF,MALF,WACEW,gBAKAE,GAfF,YACE,IACAF,YAA2BC,EAAU3L,UAAkBrI,EAAvD+T,UAcA9F,aAXF,YACEJ,O,SCqBYqG,EACd/S,EACA2S,EACAT,EACA7L,EACAuB,GAIE,IC1DwBoL,ED0DxBjP,EAUEsC,EAVFtC,MACM8D,EASJxB,EAVF,KAEW4M,EAQT5M,EAVF,UAGA6M,EAOE7M,EAVF,WAIA8M,EAME9M,EAVF,gBAKAZ,EAKEY,EAVF,KAMAqF,EAIErF,EAVF,MAOAe,EAGEf,EAVF,SAQAiI,EAEEjI,EAVF,eASA8G,EACE9G,EAVF,cAaI+H,EAAgBuE,EAAtB,wBACMtE,EAAa6D,EAAA,KAAW,YAAW,OAAAkB,EAAA,2BACnClM,E,SExEkBA,GACxB,IAAMnB,EAAOmB,aAAb,EASA,MAH4B,CAC1BmM,QALF,YACE,OAAO7O,EAAP,IFoEgB8O,CAAlB,GACMrM,E,SGjENA,EACAgM,GAEA,IAAMnL,EAASb,YAAf,IA2BA,MAPuB,CACrBa,OADqB,EAErByL,MArBYtM,YAAd,IAsBEsH,UAZA,MAAIzG,EAAuB,MACpBmL,kBAAP,OAYAzE,QARA,MAAI1G,EAAuB,SACpBmL,iBAAP,QAQAO,YApBF,YACU,IAAAC,EAAkBhF,EAAlBgF,MAAOC,EAAWjF,EAAlB,OACR,MAAO3G,UAAP,IHuDW6L,CAAK9L,EAAlB,GACM+F,GC3EoBoF,ED2EM/L,cAAhC,GCnE8B,CAC5B5C,QANF,YACE,WAAI2O,EAAuB,EACnBxO,EAAD,EAJT,KASEoP,aATF,MD2EM5P,EAAW4J,EAAjB,aACMO,EAAYrK,EAAUC,EAA5B,GACM,E,SIzENkD,EACA2G,EACAsE,EACA7D,EACA5I,GAEQ,IAAA+N,EAAoCvM,EAApCuM,YAAajF,EAAuBtH,EAApC,UAAwBuH,EAAYvH,EAApC,QACF4M,EAAYxF,MAAlB,GAqBA,MAJ6B,CAC3ByF,WAjBiBD,MAAcjG,EAAjC,SAkBE4C,mBAdOnC,EAAA,KACA,gBACH,IAAM0F,EAASpM,IAAU1C,EAAzB,GACM+O,EAAQ9R,wBAAwB8C,EAAtC,IACMiP,EAASC,WAAWF,mBAAuB,UAAjD,IACA,SAAmBH,MAAoBpO,EAAOwO,EAAlC,GACLpF,EAAMlH,EAANkH,MAA8BJ,EAArC,MANG,IAQAb,EARA,aASA9K,KATP,MJ6DyCqR,CAAW,EAAD,MAA/C,GAAEL,EAAU,EAAZ,WAActD,EAAkB,EAAhC,mBAOA,EAA0BtC,EAAW,EAAD,QAApC,GAAEjB,EAAK,EAAP,MAASC,EAAY,EAArB,aAQAF,GAAchI,OAAwBA,EAA5C,GACQsI,EAAmBP,EAAc,EAAD,MAAbA,GAAnBO,eASF6B,GADW1J,GAAjB,KAAyB0H,EACKG,EAA9B,EACQ9H,E,SKrGRwH,EACAmC,EACA1J,GAeA,MAH8B,CAC5BD,MATF,WACE,IAAM+H,EAAY4B,EAAlB,GACM3B,EAAUxI,EAAhB,GAGA,OAAO0F,EAFKjF,EAAO8H,EAAH,EAAhB,EACA,GANY6G,ILiGIC,CAAYrH,EAAamC,EAAzBkF,GAAV7O,MAGFmC,EAAQpC,EAAQmF,EAAM,EAAGzF,EAAV,MAArB,GACMqP,EAAgB3M,EAAtB,QACM4M,EAAexP,EAArB,GA2BMwC,G,SMrIkBiN,GACxB,IAAIC,EAAJ,EAEA,gBACE,OAAO,WACDC,MAAJ,GAAiCC,KAIrC,aACEF,EAAiBvS,6BAAjBuS,GAaF,MAL4B,CAC1BG,QAASC,GAAY,EADK,GAE1B3Q,MAAO2Q,GAAY,EAFO,GAG1BC,KAAMD,GAAY,GARpB,WACE3S,+BACAuS,QNsHgBM,EAxBH,WACb,GACEC,6BAAsCA,eAAtCA,eAEFA,gCACA,IAAMC,EAAUD,qBAAhB,IAEIC,IAAYD,eAAhB,gBACEA,oBACApN,kBAEF,GACEA,iBAEF,IACEoN,wBAAsCA,cAAtCA,aACAA,wBAGFA,oBACAA,0BAKIE,GAAgB/F,EAAYxH,EAAlC,OACML,GAAWd,EAAjB,IACM3H,GAAS2H,EAAf,IACM2O,GAAc,CAAC7N,GAArB,IACMG,GAAauD,EAAW1D,GAAUoE,EAAxC,GACMhE,GAAeuH,EAAa,EAAD,QAAjC,IAQMzH,G,SO/IND,EACA2H,EACAoF,EACA5M,EACA0H,EACAxH,GAEA,cACE,IAAMwN,EAAevW,EAArB,SACMwW,EAAYxW,UAAiBqQ,EAAnC,MAEA,IACE3H,UACA6H,UAEF,IACEkF,MAAkBpF,EAAlBoF,OACApF,MAAiBrQ,EAAjBqQ,OACAtH,kBAmBJ,MAJ2B,CACzBgI,SAZF,cAEEpI,EADeE,eAAf,KAYAC,MARF,cACE,IAAM2N,EAAcpG,cAApB,GAEA1H,EADeE,UAAqB4N,EAArB5N,MAAf,MPkHe6N,CAAS,GAAD,UAAzB,GAQM9E,G,SQvJNzM,EACAgJ,EACA8G,EACA7G,EACAxH,EACA0N,GAEA,IAAMhT,EAAY2C,SAASA,WAATA,KAAlB,KAEM4O,GADUjM,EAAO,CAAC,EAAGuH,GAAP,GAAoC,CAAxD,IACoB,QAAe,cACjC,OAAOoE,SAASoE,EAAgB/D,EAAhC,MADF,IAIA,gBAIE,IAAMgE,EAAa3B,EAAA,KAAe,YAAO,OAAA4B,GAAKvV,GAAL,MACzC,OAAO8M,EAAA,KAAU,cAAiB,MAAC,CACjC/I,MAAO6K,EAAO+E,EAAP/E,GAA2B0G,EAA3B1G,GAD0B,EAEjC3K,IAAK2K,IAAkB0G,EAAlB1G,GAF4B,EAGjCpH,MAAK,MAiBT,MAJ+B,CAC7BgO,MAVF,YACE,OAAOjE,EAAA,QAAmB,cAChB,IAAA/J,EAAsBiO,EAAtBjO,MAAOzD,EAAe0R,EAAtB,MAAcxR,EAAQwR,EAAtB,IAGR,OAFA,IAAeC,cACA3R,KAAoBE,EAAnC,EAC2ByR,SAAY,CAAhC,IAAP,IAJF,KAUAL,gBAAe,GRmHIM,CAAa,EAAD,QAAjC,GA4BMd,GAAiB,CACrBzN,UADqB,GAErBN,KAFqB,EAGrBC,UAHqB,EAIrB6O,YAtBkB/O,EAAY,EAAD,S,SSjK/BC,EACA2G,GAEQ,IAAQ/F,EAAeZ,EAAvBa,OACFkO,EAAS,CAAEjU,EAAF,UAAgBC,EAAG,WAC5BiU,EAAYzP,EAAlB,GACM0P,EAAW1P,EAAjB,GACM2P,EAAW3P,EAAjB,GACM4P,EAAa5P,EAAnB,GAII6P,EAAJ,GACIC,GAAe,IAAI9D,MAAvB,UACI1J,GAAJ,EAEA,gBACEA,GAAWC,EAAXD,QACA,IAAMyN,EAAIP,EAAV,GACMvP,EAAQqC,EAAUC,EAAH,GAAYA,aAAjCwN,GACA,OAAOH,MAAP,GA+CF,MAN8B,CAC5B5L,YAvCF,YACE,IAAMqH,EAAQ2E,EAAUzN,EAAxB,GAGA,OAFAkN,SACAE,SACOvI,UAAoBqI,EAA3B,QAoCAQ,YAjCF,YACE,IAAM5E,EAAQ2E,EAAUzN,EAAxB,GACM2N,GAAU,IAAIlE,MAApB,UACMmE,EAAWD,EAAjB,EAUA,OARIC,GA1BN,KA2BQA,GAzBR,MAyB+BN,MAC3BA,OAAiBxE,EAAjBwE,OACAC,KAGFJ,qBACAC,SACOvI,UAAoBsI,EAA3B,QAqBAU,UAlBF,WACE,IACMD,GADU,IAAInE,MAApB,UACA,EACMqE,EAAeV,EAArB,MAEMrM,EAAQuM,EAAA,OAzChB,GAyCgB,KAEP,YAAgB,OAAAQ,EAAA,KAFT,MAGN,cAAY,OAAC/T,YAAeA,SAAfA,MAAD,KAHpB,GAOA,OAFAqT,MAAaQ,EA7Cf,MA6CeA,IAAbR,GACAE,KACOzI,UAAoBuI,EAA3B,QAOAK,UAAS,GTsGTM,CAAY7P,EANiB,sBAA/B,GAuBE2G,YALqB,EAMrBjG,MANqB,EAOrB2M,cAPqB,EAQrB9O,MARqB,EASrB8B,SATqB,GAUrBjB,QAVqB,EAWrBoB,WAXqB,GAYrB2F,aAAcX,EAAajH,EAAO8B,GAZb,IAarByP,aAAcpJ,EAAaX,EAAaY,EAAapI,EAbhC,IAcrBwR,eAAgBhJ,EAdK,GAerBmB,YAfqB,EAgBrBzH,aAhBqB,GAiBrBF,SAjBqB,GAkBrByP,WAAY7E,EAAWpS,EAAMwH,GAlBR,GAmBrB0P,YAAa3G,EAAY,EAAD,WAnBH,IA4BrBE,aA5BqB,GA6BrB8D,aA7BqB,EA8BrB1V,OA9BqB,GA+BrBgU,UAAWH,EAAUzL,EAAMC,EAAWyL,IAExC,UU1MK,IAAMwE,EAA8B,CACzCpT,MADyC,SAEzCkD,KAFyC,IAGzCkG,cAHyC,GAIzCjG,UAJyC,MAKzCE,UALyC,EAMzCgQ,WANyC,EAOzCC,eAPyC,eAQzCC,cARyC,cASzCnE,gBATyC,EAUzC1N,MAVyC,EAWzC8R,cAXyC,cAYzCjJ,eAZyC,EAazC5C,MAbyC,GAczCwH,WAAY,GCFd,SAASsE,EAAc,EAAvB,GAIE,IAMA,EAGA,EAEA,EACA,EAZM5P,E,WCjBN,IAAMxB,EAAN,GAEA,cAEE,OADuBA,EAAvB,IACA,GAkBF,IAAMP,EAAyB,CAC7B4R,KAhBF,YAEE,OADAC,cAA0B,YAAO,OAAAxU,EAAA,MACjC,GAeAyU,IAPF,cAEE,OADAvR,KAAiBsR,EAAA,WAAyB,YAAO,OAAAxU,IAAA,KACjD,GAMA0U,GAbF,cAEE,OADAxR,KAAiBsR,YAAyB,CAA1CtR,IACA,IAaF,SDVeyR,GACTxF,EAAalM,IACb2R,E,S3BViBtD,EAAsBuD,GAC7C,IAAIC,EAAJ,EACA,OAAO,WACL9V,uBACA8V,EAAU9V,wBAAV8V,G2BMsBC,EA+GxB,WACE,MAAgB,OAChB,IAAMpT,EAAOmQ,mBAAwBkD,EAArC,yBACIC,IAAJ,GAA2BC,IAC3BxQ,mBAnHF,KACMyQ,EAAN,EACQT,EAAYhQ,EAAZgQ,GAAID,EAAQ/P,EAAZ,IAGJ0Q,GAAJ,EACIjS,EAAU,KAAd,GAEI8R,EAAJ,EAMA,aACE,MAAiB,MAAM,IAAII,MAAV,kCAEjB,IAAMC,EAAkBN,gBAAxB,KACA,MAAsB,MAAM,IAAIK,MAAV,uCAEtB5F,IACAT,EAAStP,2BAA2B+P,EAApCT,UACAuG,E,SExD0BtT,GAC5B,IAAMuT,EAAexW,qCAArB,QAYA,MAHgC,CAC9B+D,IARF,WACE,IACE,OAAO3C,WAAWoV,4BAAlB,KACA,MAAOrV,IACT,WFiDgBsV,CAAhBF,GAGF,cAQE,GAPAG,IACAvS,EAAU,MAAuCoS,EAAjDpS,OACA2O,EAASjC,EAAOmF,EAAYvF,EAAWT,EAAQ7L,EAA/C2O,GACA3C,yBACA2C,eAAoBA,EAApBA,UACAmD,EAAenD,mBAAwBkD,EAAvCC,yBAEI9R,EAAJ,KAAkB,CAChB,IAAK2O,cAAL,UAEE,OADA6D,IACOC,EAAS,CAAErT,MAAM,IAE1BuP,sBAEE3O,aAAqBsM,EAArBtM,cAA+C6L,EAAnD,SACE8C,oCACI3O,EAAJ,gBACEf,EAAS4S,EAAY7R,EAArBf,gBAEEe,EAAJ,eACEuB,yCAKAsK,EAAJ,QACE8C,oCAEE3O,EAAJ,gBACE0S,IACAnR,oCAIF,IACEoR,YAAW,WAAM,OAAApR,EAAA,eAAjBoR,GACAV,MAIJ,cACU,IAAAhB,EAAkBjR,EAAlBiR,cACR,gBAAIvO,EAAuBzD,EAAS4S,EAApC,GACKhT,EAAYgT,EAAZhT,GAGP,aACU,IAAAqS,EAAkBlR,EAAlBkR,cACF3W,EAAS6P,GAAf,GACkBwI,GAAlB,GACAC,SAAkB,YAAW,OAAAhU,EAAYgN,EAAD,GAAX,MAC7BtR,WAAe,YAAW,OAAA0E,EAAS4M,EAAD,GAAR,MAG5B,aACE8C,gCACAA,+BACAA,mBACA3C,cACA2C,oBACAA,uBACA9P,EAAYgT,EAAY7R,EAAxBnB,gBACAgN,WAAe,YAAW,OAAAhN,EAAYkO,EAAO/M,EAAnB,kBAC1BuB,kBACAA,qBACAA,uBACAA,qBAGF,cACE,MACA,IACMuR,EAAa,EAAc,CAAEjG,WADhBkG,KACnB,GACAP,IACAC,KACAlR,kBAiBF,cACE,IAAMN,EAAW0N,EAAOnW,EAAS,SAAhBmW,YAAjB,MACMqE,EAAOhT,sBAAb,YACA,OAAO2O,qBAA0BA,WAAjC,IAGF,cACE,IAAMpU,EAAS6P,EAAf,GACA,OAAOuE,EAAA,qBAA2B,YAAW,WAAApU,EAAA,cAG/C,gBACEoU,0CACA,GAAeA,mBAA6B9N,GAA7B8N,GA+BjB,aACE,OAAOA,QAAP,MAiDF,OAxMA8D,KAkLgC,CAC9BQ,cA/CF,WAEE,OADatE,oBAAb,GACO9K,QAAekP,KA8CtBG,cA3CF,WAEE,OADavE,qBAAb,GACOwE,QAAeJ,KA0CtB7O,aAvBF,WACE,OAAOyK,cAAP,gBAuBAyE,cAZF,WACE,UAYAC,qBArBF,WACE,UAqBAC,QA5FF,WACE,IACAd,IACAP,KACA1Q,oBAyFA+P,IAP8B,EAQ9BC,GAR8B,EAS9BgC,mBAjCF,WACE,OAAO5E,gBAAP,OAiCAqD,OAV8B,EAW9BlR,SAvBF,WACE,UAuBA0S,WApEF,WAEErS,EADawN,oBAAb,GACQ,OAARxN,IAmEAsS,WAhEF,WAEEtS,EADawN,qBAAb,GACQ,MAARxN,IA+DAwP,eA9CF,WACE,OAAOhC,qBAA0BA,WAAjC,QA8CA+E,eAnDF,WACE,OAAO/E,kBAAuBA,iBAA9B,MAmDAxN,SAhB8B,EAiB9B4R,mBAjB8B,EAkB9BY,WAtBF,WACE,UAsBAvJ,aAnB8B,EAoB9BwI,gBAAe,G,mBG5OnB,SAA0B,QACxB,IAAA5S,MAAA,IAEM,MAAoB1F,EAApB,WAACsZ,EAAK,EAAN,GAAQC,EAAQ,EAAhB,GACA,EAA0BvZ,EAA1B,WAACwZ,EAAQ,EAAT,GAAWC,EAAW,EAAtB,GACAC,EAAgB1a,SAAtB,GACM2a,EAAgBC,WAA0B,W,ICXhDC,EACAC,EDcE,OCfFD,EDYuBH,EAAD,QCXtBI,EDWE,ECRA9b,wBAAgCA,eAAhCA,QACAA,OAAA,eAA2B,YACzB,QAAKA,uCAAL,IAGO6b,OAAuBC,EAA9B,QDIAJ,aAEKA,EAAP,UACC,CAACA,EALJ,IAiBA,OAVApY,aAAU,WACR,GC1BkB,qBAAXC,QACPA,OADA,UAEAA,gBAHF,eD2BE,EAA6B,CAC3B,IAAMwY,EAAWlD,EAAc2C,EAA/B,GAEA,OADAD,KACO,WAAM,oBAEbA,YAED,CAACC,EAAUG,EARdrY,IAUO,CAACmY,EAAR,K,kBEdFzW,EAAOC,QAdP,SAAiBC,EAAO8W,GAKtB,IAJA,IAAIC,EACAjT,GAAS,EACT3I,EAAS6E,EAAM7E,SAEV2I,EAAQ3I,GAAQ,CACvB,IAAIY,EAAU+a,EAAS9W,EAAM8D,SACb5E,IAAZnD,IACFgb,OAAoB7X,IAAX6X,EAAuBhb,EAAWgb,EAAShb,GAGxD,OAAOgb","file":"static/js/3.42692bd7.chunk.js","sourcesContent":["import { useRef, useState, useCallback, useEffect } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar useLatest = (function (val) {\n  var ref = useRef(val);\n  ref.current = val;\n  return ref;\n});\n\nvar observerErr = \"💡 react-cool-inview: the browser doesn't support Intersection Observer, please install polyfill: https://github.com/wellyshen/react-cool-inview#intersection-observer-polyfill\";\nvar observerWarn = \"💡 react-cool-inview: the browser doesn't support Intersection Observer v2, fallback to v1 behavior\";\n\nvar useInView = function useInView(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      root = _ref.root,\n      rootMargin = _ref.rootMargin,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? 0 : _ref$threshold,\n      trackVisibility = _ref.trackVisibility,\n      delay = _ref.delay,\n      unobserveOnEnter = _ref.unobserveOnEnter,\n      onChange = _ref.onChange,\n      onEnter = _ref.onEnter,\n      onLeave = _ref.onLeave;\n\n  var _useState = useState({\n    inView: false,\n    scrollDirection: {}\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var prevInViewRef = useRef(false);\n  var prevPosRef = useRef({});\n  var observerRef = useRef();\n  var warnedRef = useRef(false);\n  var onChangeRef = useLatest(onChange);\n  var onEnterRef = useLatest(onEnter);\n  var onLeaveRef = useLatest(onLeave);\n  var ref = useRef();\n  var unobserve = useCallback(function () {\n    if (observerRef.current) {\n      observerRef.current.disconnect();\n      prevPosRef.current = {};\n    }\n  }, []);\n  var observe = useCallback(function (element) {\n    if (element && element !== ref.current) {\n      unobserve();\n      ref.current = element;\n    }\n\n    if (observerRef.current && ref.current) observerRef.current.observe(ref.current);\n  }, [unobserve]);\n  var updatePosition = useCallback(function () {\n    if (!ref.current) return;\n\n    var _ref$current$getBound = ref.current.getBoundingClientRect(),\n        x = _ref$current$getBound.x,\n        y = _ref$current$getBound.y;\n\n    prevPosRef.current = {\n      x: x,\n      y: y\n    };\n  }, [ref]);\n  useEffect(function () {\n    if (!(\"IntersectionObserver\" in window) || !(\"IntersectionObserverEntry\" in window)) {\n      console.error(observerErr);\n      return function () {\n        return null;\n      };\n    } // eslint-disable-next-line compat/compat\n\n\n    observerRef.current = new IntersectionObserver(function (_ref2) {\n      var entry = _ref2[0];\n      var intersectionRatio = entry.intersectionRatio,\n          isIntersecting = entry.isIntersecting,\n          _entry$boundingClient = entry.boundingClientRect,\n          x = _entry$boundingClient.x,\n          y = _entry$boundingClient.y,\n          isVisible = entry.isVisible;\n      var scrollDirection = {};\n      var min = Array.isArray(threshold) ? Math.min.apply(Math, threshold) : threshold;\n      var inView = isIntersecting !== undefined ? isIntersecting : intersectionRatio > 0;\n      inView = min > 0 ? intersectionRatio >= min : inView; // @ts-expect-error\n\n      if (x < prevPosRef.current.x) scrollDirection.horizontal = \"left\"; // @ts-expect-error\n\n      if (x > prevPosRef.current.x) scrollDirection.horizontal = \"right\";\n      prevPosRef.current.x = x; // @ts-expect-error\n\n      if (y < prevPosRef.current.y) scrollDirection.vertical = \"up\"; // @ts-expect-error\n\n      if (y > prevPosRef.current.y) scrollDirection.vertical = \"down\";\n      prevPosRef.current.y = y;\n      var e = {\n        entry: entry,\n        scrollDirection: scrollDirection,\n        observe: observe,\n        unobserve: unobserve\n      };\n\n      if (trackVisibility) {\n        if (isVisible === undefined && !warnedRef.current) {\n          console.warn(observerWarn);\n          warnedRef.current = true;\n        }\n\n        if (isVisible !== undefined) inView = isVisible;\n      }\n\n      if (inView && !prevInViewRef.current) {\n        if (unobserveOnEnter) unobserve();\n        if (onEnterRef.current) onEnterRef.current(e);\n      }\n\n      if (!inView && prevInViewRef.current && onLeaveRef.current) onLeaveRef.current(e);\n      if (onChangeRef.current) onChangeRef.current(_extends({}, e, {\n        inView: inView\n      }));\n      setState({\n        inView: inView,\n        scrollDirection: scrollDirection,\n        entry: entry\n      });\n      prevInViewRef.current = inView;\n    }, {\n      root: root,\n      rootMargin: rootMargin,\n      threshold: threshold,\n      trackVisibility: trackVisibility,\n      delay: delay\n    });\n    observe();\n    return function () {\n      return unobserve();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [unobserveOnEnter, root, rootMargin, // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(threshold), trackVisibility, delay, observe, unobserve]);\n  return _extends({}, state, {\n    observe: observe,\n    unobserve: unobserve,\n    updatePosition: updatePosition\n  });\n};\n\nexport default useInView;\nexport { observerErr, observerWarn };\n","var baseSum = require('./_baseSum'),\n    identity = require('./identity');\n\n/**\n * Computes the sum of the values in `array`.\n *\n * @static\n * @memberOf _\n * @since 3.4.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {number} Returns the sum.\n * @example\n *\n * _.sum([4, 2, 8, 6]);\n * // => 20\n */\nfunction sum(array) {\n  return (array && array.length)\n    ? baseSum(array, identity)\n    : 0;\n}\n\nmodule.exports = sum;\n","export type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / Math.abs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return Math.abs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0\n  const diff = deltaAbs(Math.abs(valueB), Math.abs(valueA))\n  return Math.abs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function debounce(callback: () => void, time: number): () => void {\n  let timeout = 0\n  return (): void => {\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType[]): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function arrayLast<GenericType>(array: GenericType[]): GenericType {\n  return array[lastIndex(array)]\n}\n\nexport function lastIndex<GenericType>(array: GenericType[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function removeClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && !cl.contains(className)) cl.add(className)\n}\n","import { LimitType } from './limit'\nimport { mathSign } from './utils'\n\nexport type CounterType = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  limit: LimitType,\n  loop: boolean,\n  start: number,\n): CounterType {\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  const withinLimit = limit[type]\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    if (n !== 0) {\n      const sign = mathSign(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): CounterType {\n    return Counter(limit, loop, get())\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","type EventRemoverType = () => void\ntype EventHandlerType = EventListener | EventListenerObject | null\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: keyof WindowEventMap,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","export type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { AnimationType } from './animation'\nimport { CounterType } from './counter'\nimport { DirectionType } from './direction'\nimport { DragTrackerType } from './dragTracker'\nimport { EventEmitterType } from './eventEmitter'\nimport { AxisType } from './axis'\nimport { EventStore } from './eventStore'\nimport { LimitType } from './limit'\nimport { ScrollBodyType } from './scrollBody'\nimport { ScrollTargetType } from './scrollTarget'\nimport { ScrollToType } from './scrollTo'\nimport { Vector1D, Vector1DType } from './vector1d'\nimport { deltaAbs, factorAbs, mathSign } from './utils'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragFree: boolean,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  limit: LimitType,\n  events: EventEmitterType,\n): DragHandlerType {\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 12\n  const dragThreshold = 4\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number): number {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n    const destination = force + location.get()\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      const next = index.clone().add(mathSign(force) * -1)\n      return scrollTarget.byIndex(next.get(), 0).distance\n    }\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = deltaAbs(moveScroll, startScroll.get())\n      const diffCross = deltaAbs(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.applyTo(diff))\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(direction.applyTo(rawForce))\n    const speedFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(baseSpeed + baseSpeed * speedFactor)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","export type LimitType = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? max : min\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  const self: LimitType = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (v: Vector1DType) => ScrollBodyType\n  settle: (v: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1DType): void {\n    v.divide(mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1DType): ScrollBodyType {\n    attraction.set(v).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1DType): boolean {\n    const diff = v.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './limit'\nimport { ScrollBodyType } from './scrollBody'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollBoundsType = {\n  constrain: (v: Vector1DType, pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  scrollBody: ScrollBodyType,\n): ScrollBoundsType {\n  const pullBackThreshold = 10\n  let disabled = false\n\n  function shouldConstrain(target: Vector1DType): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(target: Vector1DType, pointerDown: boolean): void {\n    if (!shouldConstrain(target)) return\n    const friction = pointerDown ? 0.7 : 0.4\n    const diffToTarget = target.get() - location.get()\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snaps: number[],\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snaps[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { PxToPercentType } from './pxToPercent'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollLooperType = {\n  loop: (vectors: Vector1DType[], direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  pxToPercent: PxToPercentType,\n  limit: LimitType,\n  location: Vector1DType,\n): ScrollLooperType {\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1DType[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './alignment'\nimport { AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { arrayLast, groupArray } from './utils'\n\nexport type ScrollSnapType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnap(\n  axis: AxisType,\n  alignment: AlignmentType,\n  pxToPercent: PxToPercentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slidesToScroll: number,\n): ScrollSnapType {\n  const { startEdge, endEdge } = axis\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupArray(slideRects, slidesToScroll)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map(pxToPercent.measure)\n      .map((snap) => -Math.abs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const groupedSnaps = groupArray(snaps, slidesToScroll).map((g) => g[0])\n    const alignments = measureSizes().map(alignment.measure)\n    return groupedSnaps.map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { CounterType } from './counter'\nimport { LimitType } from './limit'\nimport { Vector1DType } from './vector1d'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  indexCurrent: CounterType,\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = indexCurrent\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './slidesInView'\nimport { Vector1DType } from './vector1d'\n\ntype LoopEdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  point: number\n  location: number\n  index: number\n  getTarget: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scrollLocation: Vector1DType,\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(\n    indexes: number[],\n    edge: LoopEdgeType,\n  ): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const getTarget = (): number =>\n        scrollLocation.get() > point ? initial : altered\n      return { point, getTarget, index, location: -1 }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach((loopPoint) => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget()\n      if (target !== location) {\n        slides[index].style[axis.startEdge] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[axis.startEdge] = ''\n    })\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { EventStore, EventStoreType } from './eventStore'\nimport { ScrollToType } from './scrollTo'\n\nexport type SlideFocusType = {\n  addActivationEvents: (slides: HTMLElement[]) => void\n  removeAllEvents: EventStoreType['removeAll']\n}\n\nexport function SlideFocus(\n  rootNode: HTMLElement,\n  scrollTo: ScrollToType,\n  slidesToScroll: number,\n): SlideFocusType {\n  const eventStore = EventStore()\n  const removeAllEvents = eventStore.removeAll\n  let lastTabPressTime = 0\n\n  function registerTabPress(event: Event): void {\n    if ((event as KeyboardEvent).keyCode !== 9) return\n    lastTabPressTime = new Date().getTime()\n  }\n\n  function addFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n      if (diffTime > 10) return\n\n      rootNode.scrollLeft = 0\n      const selectedIndex = Math.floor(index / slidesToScroll)\n      scrollTo.index(selectedIndex, 0)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function addActivationEvents(slides: HTMLElement[]): void {\n    eventStore.add(document, 'keydown', registerTabPress, false)\n    slides.forEach(addFocusEvent)\n  }\n\n  const self: SlideFocusType = {\n    addActivationEvents,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { DirectionType } from './direction'\nimport { Vector1DType } from './vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const containerStyle = container.style\n  const translate = axis.scroll === 'x' ? x : y\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.applyTo(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation, AnimationType } from './animation'\nimport { Axis, AxisType } from './axis'\nimport { Counter, CounterType } from './counter'\nimport { Direction, DirectionType } from './direction'\nimport { DragHandler, DragHandlerType } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitterType } from './eventEmitter'\nimport { Limit, LimitType } from './limit'\nimport { OptionsType } from './options'\nimport { PxToPercent, PxToPercentType } from './pxToPercent'\nimport { ScrollBody, ScrollBodyType } from './scrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './scrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget, ScrollTargetType } from './scrollTarget'\nimport { ScrollTo, ScrollToType } from './scrollTo'\nimport { SlideLooper, SlideLooperType } from './slideLooper'\nimport { SlideFocus, SlideFocusType } from './slideFocus'\nimport { SlidesInView, SlidesInViewType } from './slidesInView'\nimport { SlideSizes } from './slideSizes'\nimport { Translate, TranslateType } from './translate'\nimport { arrayKeys, arrayLast, lastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type Engine = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  pxToPercent: PxToPercentType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  slideFocus: SlideFocusType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  events: EventEmitterType,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const pxToPercent = PxToPercent(axis.measureSize(containerRect))\n  const viewSize = pxToPercent.totalPercent\n  const alignment = Alignment(align, viewSize)\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    pxToPercent,\n    slides,\n    slideRects,\n    loop,\n  )\n  const { snaps, snapsAligned } = ScrollSnap(\n    axis,\n    alignment,\n    pxToPercent,\n    containerRect,\n    slideRects,\n    slidesToScroll,\n  )\n  const contentSize = arrayLast(snaps) * -1 + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snaps,\n    snapsAligned,\n    containScroll,\n  )\n\n  const contain = !loop && containScroll !== ''\n  const scrollSnaps = contain ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(Limit(0, lastIndex(scrollSnaps)), loop, startIndex)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) {\n      engine.scrollBounds.constrain(target, engine.dragHandler.pointerDown())\n    }\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      events.emit('settle')\n    }\n    if (!settled) {\n      events.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(loopVectors, engine.scrollBody.direction())\n      engine.slideLooper.loop(slides)\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    index,\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    events,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    dragFree,\n    DragTracker(axis, pxToPercent),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    limit,\n    events,\n  )\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, location, scrollBody),\n    scrollLooper: ScrollLooper(contentSize, pxToPercent, limit, location),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideFocus: SlideFocus(root, scrollTo, slidesToScroll),\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n    ),\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","export type PxToPercentType = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercentType {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    if (viewInPx === 0) return 0\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercentType = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  applyTo: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function applyTo(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    applyTo,\n  }\n  return self\n}\n","import { DirectionOptionType } from './direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return contentDirection === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return contentDirection === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { arrayLast, lastIndex } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n  slides: HTMLElement[],\n  slideRects: DOMRect[],\n  loop: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const sizesInPx = slideRects.map(measureSize)\n  const slideSizes = sizesInPx.map(pxToPercent.measure)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isLast = index === lastIndex(rects)\n        const style = window.getComputedStyle(arrayLast(slides))\n        const endGap = parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n        if (isLast) return sizesInPx[index] + (loop ? endGap : 0)\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { AnimationType } from './animation'\nimport { CounterType } from './counter'\nimport { EventEmitterType } from './eventEmitter'\nimport { ScrollTargetType, TargetType } from './scrollTarget'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  events: EventEmitterType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number) => number[]\n  findSlideBounds: (offset: number, threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99)\n  const offsets = loop ? [0, contentSize, -contentSize] : [0]\n  const slideBounds = offsets.reduce((a: SlideBoundType[], offset) => {\n    return a.concat(findSlideBounds(offset, threshold))\n  }, [])\n\n  function findSlideBounds(\n    offset: number,\n    threshold?: number,\n  ): SlideBoundType[] {\n    const thresholds = slideSizes.map((s) => s * (threshold || 0))\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type DragTrackerType = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOptionType) => Vector1DType\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n): DragTrackerType {\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOptionType): Vector1DType {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map((trackPoint) => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './alignment'\nimport { AxisOptionType } from './axis'\nimport { DirectionOptionType } from './direction'\nimport { ScrollContainOptionType } from './scrollContain'\n\nexport type OptionsType = {\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { Engine } from './components/engine'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptionsType } from './components/options'\nimport { OptionsPseudo, OptionsPseudoType } from './components/optionsPseudo'\nimport { addClass, debounce, removeClass } from './components/utils'\nimport {\n  EventEmitter,\n  EmblaEventType,\n  EventEmitterType,\n} from './components/eventEmitter'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitterType['off']\n  on: EventEmitterType['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType) => void\n  rootNode: () => HTMLElement\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions?: EmblaOptionsType,\n): EmblaCarouselType {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let optionsPseudo: OptionsPseudoType\n  let rootNodeSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function setupElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node 😢')\n\n    const sliderContainer = sliderRoot.querySelector('*')\n    if (!sliderContainer) throw new Error('Missing container node 😢')\n\n    container = sliderContainer as HTMLElement\n    slides = Array.prototype.slice.call(container.children)\n    optionsPseudo = OptionsPseudo(sliderRoot)\n  }\n\n  function activate(partialOptions?: EmblaOptionsType): void {\n    setupElements()\n    options = Object.assign(options, partialOptions, optionsPseudo.get())\n    engine = Engine(sliderRoot, container, slides, options, events)\n    eventStore.add(window, 'resize', debouncedResize)\n    engine.translate.to(engine.location)\n    rootNodeSize = engine.axis.measureSize(sliderRoot.getBoundingClientRect())\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false })\n      }\n      engine.slideLooper.loop(slides)\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n      if (options.draggableClass) {\n        addClass(sliderRoot, options.draggableClass)\n      }\n      if (options.draggingClass) {\n        events\n          .on('pointerDown', toggleDraggingClass)\n          .on('pointerUp', toggleDraggingClass)\n      }\n    }\n    if (slides.length) {\n      engine.slideFocus.addActivationEvents(slides)\n    }\n    if (options.selectedClass) {\n      toggleSelectedClass()\n      events\n        .on('select', toggleSelectedClass)\n        .on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEventType): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach((index) => removeClass(slides[index], selectedClass))\n    inView.forEach((index) => addClass(slides[index], selectedClass))\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.slideFocus.removeAllEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach((slide) => removeClass(slide, options.selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function reActivate(partialOptions?: EmblaOptionsType): void {\n    if (!activated) return\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    if (!activated) return\n    const size = engine.axis.measureSize(sliderRoot.getBoundingClientRect())\n    if (rootNodeSize !== size) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, direction?: number): void {\n    engine.scrollBody.useBaseMass().useBaseSpeed()\n    if (activated) engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return sliderRoot\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitterType = {\n  emit: (evt: EmblaEventType) => EventEmitterType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n}\n\nexport function EventEmitter(): EventEmitterType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    const eventListeners = listeners[evt]\n    return eventListeners || []\n  }\n\n  function emit(evt: EmblaEventType): EventEmitterType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventEmitterType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { EmblaOptionsType } from './options'\n\nexport type OptionsPseudoType = {\n  get: () => EmblaOptionsType\n}\n\nexport function OptionsPseudo(node: HTMLElement): OptionsPseudoType {\n  const psuedoString = window.getComputedStyle(node, ':before').content\n\n  function get(): EmblaOptionsType {\n    try {\n      return JSON.parse(psuedoString.slice(1, -1).replace(/\\\\/g, ''))\n    } catch (error) {} // eslint-disable-line no-empty\n    return {}\n  }\n\n  const self: OptionsPseudoType = {\n    get,\n  }\n  return self\n}\n","import { useRef, useEffect, useState, useMemo } from 'react'\nimport EmblaCarousel, { EmblaCarouselType } from '../vanilla'\nimport { EmblaOptionsType } from '../vanilla/components/options'\nimport { areEqualShallow, canUseDOM } from './utils'\n\ntype ViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  ViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n): UseEmblaCarouselType {\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n  const storedOptions = useRef<EmblaOptionsType>(options)\n  const activeOptions = useMemo<EmblaOptionsType>(() => {\n    if (!areEqualShallow(storedOptions.current, options)) {\n      storedOptions.current = options\n    }\n    return storedOptions.current\n  }, [storedOptions, options])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      const newEmbla = EmblaCarousel(viewport, activeOptions)\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, activeOptions, setEmbla])\n\n  return [setViewport as ViewportRefType, embla]\n}\n\nexport { useEmblaCarousel }\n","export function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areEqualShallow(\n  objectA: { [key: string]: any },\n  objectB: { [key: string]: any },\n): boolean {\n  return (\n    Object.keys(objectA).length === Object.keys(objectB).length &&\n    Object.keys(objectA).every((objectKey) => {\n      if (!Object.prototype.hasOwnProperty.call(objectB, objectKey)) {\n        return false\n      }\n      return objectA[objectKey] === objectB[objectKey]\n    })\n  )\n}\n","/**\n * The base implementation of `_.sum` and `_.sumBy` without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {number} Returns the sum.\n */\nfunction baseSum(array, iteratee) {\n  var result,\n      index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var current = iteratee(array[index]);\n    if (current !== undefined) {\n      result = result === undefined ? current : (result + current);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseSum;\n"],"sourceRoot":""}