{"version":3,"sources":["utils/Cache.js","utils/Promise.js","utils/Torrents.js","common/Post/components/Video/index.js","images/share.svg","common/Post/index.tsx"],"names":["getCachedFile","fileName","a","FileCache","_init","Promise","resolve","reject","init","then","console","log","persist","status","persistent","load","cachedFile","createURL","warn","renderCachedFile","fileURL","selector","elements","document","querySelectorAll","length","forEach","element","src","muted","autoplay","saveFile","buffer","save","runSerial","tasks","result","task","supportedFileTypes","formats","options","_getFileType","Object","values","reduce","supportedFormats","fileType","file","extension","name","split","slice","entries","filter","includes","supportedFileType","webTorrentClient","initializeClient","WebTorrent","default","showDynamicThumbnail","thumbnailFile","item","thumbnailFileType","thumbnailTarget","magnetURI","dynamicThumbnailTarget","querySelector","classList","add","remove","getCacheId","id","key","renderTorrent","type","torrentMode","torrent","target","torrentElements","torrentElement","contains","contentURL","decodeURIComponent","replace","format","toLowerCase","endsWith","compatibleURL","setAttribute","renderTo","getThumbnailRenderer","thumbnailFileNames","getCacheFileName","thumbnails","sanitizedName","join","thumbnailName","thumbnailIndex","indexOf","cachedThumbnail","attachMedia","posts","all","map","post","contentItems","supportedItems","get","files","match","renderThumbnail","destroy","on","getBlob","err","blob","dataset","played","getAttribute","torrentTasks","torrents","detachTorrent","Video","index","tipValue","tipCounter","hideRibbon","videoRef","useRef","useState","playing","setPlaying","observe","useInView","trackVisibility","delay","onEnter","current","play","onLeave","pause","togglePlayingStatus","useCallback","updatedPlaying","videoHeight","useMemo","CSS","supports","aspectRatio","height","onPause","readyState","className","ref","style","classNames","onClick","data-torrent","data-file-key","alt","data-played","controls","TipRibbon","memo","Post","publicKey","openTipModal","openUnlockModal","openDeleteModal","undefined","openShareModal","_","dispatch","Store","unlockedContent","content","authenticated","auth","useEmblaCarousel","slidesToScroll","align","carouselRef","carouselAPI","author","React","tips","sum","sliderLength","setSliderLength","activeSlide","setActiveSlide","isPrivate","setIsPrivate","mediaAttached","setMediaAttached","mediaDetached","setMediaDetached","isOnlineNode","useEffect","subPostContent","subPostTips","liveStatus","stream","find","viewersCounter","getMediaContent","k","e","path","parseContent","text","finalMagnetURI","cached","Image","postId","width","Common","playbackMagnet","Stream","nextSlide","canScrollNext","scrollNext","prevSlide","canScrollPrev","scrollPrev","handleUserKeyDown","updateActiveSlide","selectedScrollSnap","scrollSnapList","window","addEventListener","removeEventListener","off","tipPost","targetType","postID","unlockPost","deletePost","shared","sharePost","url","location","host","navigator","share","displayName","clipboard","writeText","Tooltip","rebuild","useLayoutEffect","ShockAvatar","Pad","amt","insideRow","to","live","waiting","wasLive","DateTime","fromMillis","date","toRelative","getTextContent","Array","from","scrollTo","data-tip","ShareIcon","color","marginLeft"],"mappings":"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","file":"static/js/39.699c57f9.chunk.js","sourcesContent":["import FileCache from \"browser-file-storage\";\n\nexport const DB_NAME = \"ShockWalletStore\";\n\nexport const init = () =>\n  new Promise((resolve, reject) => {\n    FileCache.init(DB_NAME)\n      .then(() => {\n        console.log(\"File cache initialized!\");\n        return FileCache.persist();\n      })\n      .then(status => {\n        if (status.persistent) {\n          resolve(status);\n        } else {\n          reject(status);\n        }\n      });\n  });\n\nexport const getCachedFile = async fileName => {\n  try {\n    if (!FileCache._init) {\n      await init();\n    }\n\n    const cachedFile = await FileCache.load(fileName);\n    return cachedFile.createURL();\n  } catch (err) {\n    console.warn(err);\n    return false;\n  }\n};\n\nexport const renderCachedFile = (fileURL, selector) => {\n  const elements = document.querySelectorAll(selector);\n  if (elements && elements.length) {\n    elements.forEach(element => {\n      if (!element.src) {\n        element.src = fileURL;\n        element.muted = true;\n        element.autoplay = false;\n      }\n    });\n  }\n  return !!elements?.length;\n};\n\nexport const saveFile = (fileName, buffer) => {\n  return FileCache.save(fileName, buffer);\n};\n","export const runSerial = tasks => {\n  let result = Promise.resolve();\n  tasks.forEach(task => {\n    result = result.then(() => task());\n  });\n  return result;\n};\n","import { getCachedFile, renderCachedFile, saveFile } from \"./Cache\";\nimport { runSerial } from \"./Promise\";\n\nexport const supportedFileTypes = {\n  \"video/embedded\": {\n    formats: [\"mp4\", \"webm\"],\n    element: \"video\",\n    options: {\n      autoplay: false,\n      muted: true\n    }\n  },\n  \"image/embedded\": {\n    formats: [\"jpg\", \"png\", \"webp\", \"jpeg\"],\n    element: \"img\",\n    options: {}\n  }\n};\n\nexport const supportedFormats = Object.values(supportedFileTypes).reduce(\n  (supportedFormats, fileType) => [...supportedFormats, ...fileType.formats],\n  []\n);\n\nconst _getFileType = file => {\n  if (!file) {\n    return null;\n  }\n\n  const extension = file.name?.split(\".\")?.slice(-1)[0];\n  const [supportedFileType] = Object.entries(supportedFileTypes).filter(\n    ([type, options]) => options.formats.includes(extension)\n  );\n\n  if (supportedFileType) {\n    const [name, fileType] = supportedFileType;\n    return {\n      name,\n      ...fileType\n    };\n  }\n\n  return null;\n};\n\nexport let webTorrentClient = null;\n\nexport const initializeClient = async () => {\n  if (!webTorrentClient) {\n    const WebTorrent = await import(\"webtorrent\");\n    webTorrentClient = new WebTorrent.default();\n  }\n\n  return webTorrentClient;\n};\n\nconst showDynamicThumbnail = ({ thumbnailFile, fileType, item }) => {\n  const thumbnailFileType = _getFileType(thumbnailFile);\n  const thumbnailTarget = `${\n    thumbnailFileType?.element ?? \"img\"\n  }[data-torrent=\"${item.magnetURI}\"]`;\n  const dynamicThumbnailTarget = `.dynamic-thumbnail[data-torrent=\"${item.magnetURI}\"]`;\n\n  if (!thumbnailFile && fileType.element === \"video\") {\n    document.querySelector(thumbnailTarget)?.classList.add(\"hidden\");\n    document.querySelector(dynamicThumbnailTarget)?.classList.remove(\"hidden\");\n  }\n};\n\nconst getCacheId =\n  ({ id, key }) =>\n  file =>\n    `${id}-${key}-${file.name}`;\n\nconst renderTorrent = ({ file, type, torrentMode, torrent }) => {\n  const element = type.element;\n  const target = `${element}[data-torrent=\"${torrent.magnetURI}\"]`;\n  const torrentElements = document.querySelectorAll(target);\n  console.log(\"Torrent Elements:\", torrentElements);\n  torrentElements.forEach(torrentElement => {\n    // Don't render hidden videos\n    if (torrentElement.classList.contains(\"hidden\")) {\n      return;\n    }\n    const contentURL = decodeURIComponent(\n      torrent.magnetURI.replace(/.*(ws=)/gi, \"\")\n    );\n    const [compatibleURL] = type.formats.filter(format =>\n      contentURL.toLowerCase().endsWith(`.${format.toLowerCase()}`)\n    );\n\n    if (torrentMode || !compatibleURL) {\n      file.renderTo(torrentElement, type.options);\n      return;\n    }\n\n    torrentElement.setAttribute(\"src\", contentURL);\n  });\n};\n\nexport const isURLCompatible = ({ url, type = \"video/embedded\" }) => {\n  const fileType = supportedFileTypes[type];\n  const [compatibleURL] = fileType.formats.filter(format =>\n    url.toLowerCase().endsWith(`.${format.toLowerCase()}`)\n  );\n\n  return !!compatibleURL;\n};\n\nconst getThumbnailRenderer =\n  ({ thumbnailFileNames, getCacheFileName, torrentMode }) =>\n  async ({ fileName, thumbnails, item, fileType }) => {\n    const sanitizedName = fileName.split(\".\").slice(0, -1).join(\".\");\n    const thumbnailName = `${sanitizedName}-thumb`;\n    const thumbnailIndex = thumbnailFileNames.indexOf(thumbnailName);\n    const thumbnailFile = thumbnails[thumbnailIndex];\n    const thumbnailFileType = thumbnailFile\n      ? _getFileType(thumbnailFile)\n      : null;\n    const thumbnailTarget = `${\n      thumbnailFileType?.element ?? \"img\"\n    }[data-torrent=\"${item.magnetURI}\"]`;\n\n    if (fileType.element === \"video\" && thumbnailFile) {\n      const cachedThumbnail = await getCachedFile(\n        getCacheFileName(thumbnailFile)\n      );\n\n      document.querySelector(thumbnailTarget)?.classList.remove(\"hidden\");\n\n      if (cachedThumbnail) {\n        renderCachedFile(cachedThumbnail, thumbnailTarget);\n        return;\n      }\n\n      renderTorrent({\n        file: thumbnailFile,\n        type: thumbnailFileType,\n        torrentMode,\n        torrent: item\n      });\n\n      return;\n    }\n\n    if (fileType.element === \"video\" && !thumbnailFile) {\n      showDynamicThumbnail({\n        thumbnailFile,\n        fileType,\n        item\n      });\n\n      return;\n    }\n\n    return {\n      thumbnailFile\n    };\n  };\n\nexport const attachMedia = async (posts = [], torrentMode = true) => {\n  const torrentTasks = await Promise.all(\n    posts.map(async post => {\n      const { contentItems, id } = post;\n      const supportedItems = Object.entries(contentItems).filter(\n        ([, item]) => supportedFileTypes[item.type]\n      );\n\n      if (!supportedItems) {\n        return [];\n      }\n\n      const webTorrentClient = await initializeClient();\n\n      return supportedItems.map(\n        ([key, item]) =>\n          () =>\n            new Promise(resolve => {\n              const getCacheFileName = getCacheId({ id, key });\n              const torrentExists = webTorrentClient.get(item.magnetURI);\n\n              if (torrentExists) {\n                resolve(true);\n                return;\n              }\n\n              webTorrentClient.add(item.magnetURI, async torrent => {\n                // Proceed to the next torrent in queue\n                resolve(true);\n\n                const files = torrent.files.filter(file => {\n                  const extension = file.name?.split(\".\")?.slice(-1)[0];\n                  const supportedFileType = Object.values(\n                    supportedFileTypes\n                  ).filter(options => options.formats.includes(extension))[0];\n                  if (supportedFileType) {\n                    const fileType = supportedFileType;\n                    const matched = fileType.formats.includes(extension);\n                    return matched;\n                  }\n                  return false;\n                });\n\n                const thumbnails = files.filter(file =>\n                  file.name.match(/-thumb\\.([\\w\\d]){2,4}$/gi)\n                );\n                const thumbnailFileNames = thumbnails.map(file =>\n                  file.name.replace(/\\.([\\w\\d]){2,4}$/gi, \"\")\n                );\n                const renderThumbnail = getThumbnailRenderer({\n                  getCacheFileName,\n                  thumbnailFileNames,\n                  torrentMode\n                });\n\n                files.map(async file => {\n                  // Skip thumbnails\n                  if (thumbnailFileNames.includes(file.name)) {\n                    return;\n                  }\n\n                  const fileType = _getFileType(file);\n\n                  if (!fileType) {\n                    return;\n                  }\n\n                  const fileName = getCacheFileName(file);\n\n                  const element = fileType.element;\n                  const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n                  const cachedFile = await getCachedFile(fileName);\n\n                  renderThumbnail({\n                    fileName: file.name,\n                    thumbnails,\n                    fileType,\n                    item\n                  });\n\n                  if (cachedFile) {\n                    const torrent = webTorrentClient.get(item.magnetURI);\n\n                    if (torrent) {\n                      torrent.destroy();\n                    }\n\n                    renderCachedFile(cachedFile, target);\n                    return;\n                  }\n\n                  renderTorrent({\n                    file,\n                    type: fileType,\n                    torrentMode,\n                    torrent: item\n                  });\n                });\n\n                torrent.on(\"done\", () => {\n                  files.map(file => {\n                    const fileType = _getFileType(file);\n                    const fileName = getCacheFileName(file);\n                    const element = fileType.element;\n                    const target = `${element}.torrent-video[data-torrent=\"${item.magnetURI}\"]`;\n\n                    file.getBlob(async (err, blob) => {\n                      if (err) {\n                        console.warn(err);\n                        return;\n                      }\n\n                      console.log(\"Caching loaded file...\", fileName, blob);\n                      await saveFile(fileName, blob);\n                      const element = document.querySelector(target);\n                      if (\n                        element?.dataset.played === \"false\" &&\n                        !element?.getAttribute(\"src\")\n                      ) {\n                        const cachedFile = await getCachedFile(fileName);\n                        renderCachedFile(cachedFile, target);\n                      }\n                    });\n                  });\n                });\n              });\n            })\n      );\n    })\n  );\n  const contentItems = torrentTasks.reduce(\n    (torrents, contentItems) => [...torrents, ...contentItems],\n    []\n  );\n\n  runSerial(contentItems);\n};\n\nexport const detachTorrent = async ({ magnetURI }) => {\n  const webTorrentClient = await initializeClient();\n  const torrent = webTorrentClient.get(magnetURI);\n\n  if (torrent) {\n    torrent.destroy();\n    return true;\n  }\n\n  return false;\n};\n","import classNames from \"classnames\";\nimport { memo, useCallback, useMemo, useRef, useState } from \"react\";\nimport useInView from \"react-cool-inview\";\nimport TipRibbon from \"../TipRibbon\";\nimport \"./css/index.scoped.css\";\n\nconst Video = ({\n  item,\n  index = 0,\n  tipValue = 0,\n  tipCounter = 0,\n  hideRibbon = false\n}) => {\n  const videoRef = useRef(null);\n  const [playing, setPlaying] = useState(false);\n  const { observe } = useInView({\n    trackVisibility: false,\n    delay: 100,\n    onEnter: () => {\n      if (videoRef.current) {\n        setPlaying(true);\n        videoRef.current.play();\n      }\n    },\n    onLeave: () => {\n      if (!videoRef.current) {\n        return;\n      }\n\n      setPlaying(false);\n      videoRef.current.pause();\n    }\n  });\n\n  const togglePlayingStatus = useCallback(() => {\n    const updatedPlaying = !playing;\n    setPlaying(updatedPlaying);\n    if (videoRef.current) {\n      if (!updatedPlaying) {\n        videoRef.current.pause();\n        return;\n      }\n\n      console.log(\"Playing video\", updatedPlaying);\n      videoRef.current.play();\n    }\n  }, [playing]);\n\n  const videoHeight = useMemo(() => {\n    if (CSS.supports(\"aspect-ratio: 16 / 9\")) {\n      return {\n        aspectRatio: \"16 / 9\"\n      };\n    }\n\n    return {\n      height: 400\n    };\n  }, []);\n\n  const onPause = useCallback(() => {\n    if (videoRef.current?.readyState === 4) {\n      setPlaying(false);\n    }\n  }, [videoRef]);\n\n  return (\n    <div className=\"media-container\" ref={observe}>\n      <div className=\"video-container\" style={videoHeight}>\n        <div\n          className={classNames({\n            \"thumbnail-container\": true,\n            \"video-hidden\": playing\n          })}\n          onClick={togglePlayingStatus}\n        >\n          <div className=\"play-btn\">\n            <i className=\"fas fa-play\" />\n          </div>\n          <img\n            className=\"video-thumbnail hidden\"\n            data-torrent={item.magnetURI}\n            data-file-key={index}\n            alt=\"Video thumbnail\"\n          />\n          <video\n            className=\"dynamic-thumbnail hidden\"\n            data-torrent={item.magnetURI}\n            data-file-key={index}\n            data-played=\"false\"\n            controls={false}\n            muted\n          />\n        </div>\n        <video\n          className={classNames({\n            \"torrent-video video-js vjs-default-skin\": true,\n            \"video-hidden\": !playing\n          })}\n          data-torrent={item.magnetURI}\n          data-file-key={index}\n          data-played=\"false\"\n          controls\n          ref={videoRef}\n          muted\n          onPause={onPause}\n        />\n        {!hideRibbon && (\n          <TipRibbon tipCounter={tipCounter} tipValue={tipValue} />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default memo(Video);\n","export default __webpack_public_path__ + \"static/media/share.8ed36b2d.svg\";","import React, {\n  memo,\n  useEffect,\n  useState,\n  useCallback,\n  useLayoutEffect\n} from \"react\";\nimport * as Common from \"shock-common\";\nimport { Link } from \"react-router-dom\";\nimport useInView from \"react-cool-inview\";\nimport { useEmblaCarousel } from \"embla-carousel/react\";\nimport Tooltip from \"react-tooltip\";\nimport classNames from \"classnames\";\nimport sum from \"lodash/sum\";\nimport { DateTime } from \"luxon\";\n\nimport * as Store from \"../../store\";\nimport { attachMedia, detachTorrent } from \"../../utils/Torrents\";\nimport { subPostContent, subPostTips } from \"../../actions/FeedActions\";\n\nimport Video from \"./components/Video\";\nimport Image from \"./components/Image\";\nimport Stream from \"./components/Stream\";\nimport ShockAvatar from \"../ShockAvatar\";\nimport Pad from \"../Pad\";\n\nimport ShareIcon from \"../../images/share.svg\";\nimport \"./css/index.scoped.css\";\n\nconst Post = ({\n  id,\n  publicKey,\n  openTipModal,\n  openUnlockModal,\n  openDeleteModal = undefined,\n  openShareModal = _ => {}\n}) => {\n  const dispatch = Store.useDispatch();\n  const unlockedContent = Store.useSelector(\n    ({ content }) => content.unlockedContent\n  );\n  const authenticated = Store.useSelector(({ auth }) => auth.authenticated);\n  const [carouselRef, carouselAPI] = useEmblaCarousel({\n    slidesToScroll: 1,\n    align: \"center\"\n  });\n  const author = Store.useSelector(Store.selectUser(publicKey));\n  const post = Store.useSelector(Store.selectSinglePost(publicKey, id));\n  const [tipCounter, tipValue] = React.useMemo(() => {\n    const tips = Object.values(\n      post.tips ||\n        {} /* cached data from previous app version won't have the tips object */\n    );\n\n    return [tips.length, sum(tips)];\n  }, [post]);\n\n  const [sliderLength, setSliderLength] = useState(0);\n  const [activeSlide, setActiveSlide] = useState(0);\n  const [isPrivate, setIsPrivate] = useState(false);\n  // Track Enter/Leave only once\n  const [mediaAttached, setMediaAttached] = useState(false);\n  const [mediaDetached, setMediaDetached] = useState(false);\n  const { observe } = useInView({\n    trackVisibility: false,\n    delay: 100,\n    onEnter: () => {\n      setMediaAttached(true);\n    },\n    onLeave: () => {\n      setMediaDetached(true);\n    }\n  });\n\n  const isOnlineNode = /*Utils.isOnline(\n    Store.useSelector(Store.selectUser(publicKey)).lastSeenApp\n  );*/ true;\n\n  useEffect(() => {\n    const subscription = dispatch(subPostContent(publicKey, id));\n    return subscription;\n  }, [dispatch, id, publicKey]);\n\n  useEffect(() => {\n    const subscription = dispatch(subPostTips(publicKey, id));\n    return subscription;\n  }, [dispatch, id, publicKey]);\n\n  const liveStatus = React.useMemo<Common.LiveStatus | null>(() => {\n    const stream = Object.values(post.contentItems ?? {}).find(\n      item => item.type === \"stream/embedded\"\n    ) as Common.EmbeddedStream;\n\n    if (stream) {\n      return stream.liveStatus;\n    }\n\n    return null;\n  }, [post.contentItems]);\n\n  const viewersCounter = React.useMemo<number | null>(() => {\n    const stream = Object.values(post.contentItems ?? {}).find(\n      item => item.type === \"stream/embedded\"\n    ) as Common.EmbeddedStream;\n\n    if (stream && stream.liveStatus === \"live\") {\n      return stream.viewersCounter;\n    }\n\n    return null;\n  }, [post.contentItems]);\n\n  const getMediaContent = useCallback(() => {\n    return Object.entries(post.contentItems ?? {}).filter(\n      ([_, item]) => item.type !== \"text/paragraph\"\n    );\n  }, [post.contentItems]);\n\n  const getTextContent = () => {\n    return Object.entries(post.contentItems ?? {}).filter(\n      ([_, item]) => item.type === \"text/paragraph\"\n    );\n  };\n\n  useEffect(() => {\n    getMediaContent().forEach(([k, e]) => {\n      const path = `${publicKey}>posts>${k}`;\n      // @ts-expect-error\n      if (e.isPrivate && !unlockedContent[path]) {\n        setIsPrivate(true);\n      }\n    });\n  }, [getMediaContent, publicKey, unlockedContent]);\n\n  const parseContent = ([key, item]: [string, Common.ContentItem], index) => {\n    if (item.type === \"text/paragraph\") {\n      return <p key={key}>{item.text}</p>;\n    }\n\n    let finalMagnetURI = \"\";\n    if (item.isPrivate) {\n      const path = `${publicKey}>posts>${id}`;\n      const cached = unlockedContent[path];\n      if (cached) {\n        finalMagnetURI = cached;\n      } else {\n        return (\n          <div key={key}>\n            <i className=\"fas fa-lock fa-10x\"></i>\n          </div>\n        );\n      }\n    }\n\n    if (item.type === \"image/embedded\") {\n      return (\n        <Image\n          id={key}\n          item={{\n            ...item,\n            magnetURI: finalMagnetURI || item.magnetURI\n          }}\n          index={index}\n          postId={id}\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          key={`${id}-${index}`}\n          hideRibbon={undefined}\n          width={undefined}\n        />\n      );\n    }\n\n    if (item.type === \"video/embedded\") {\n      return (\n        <Video\n          item={{\n            ...item,\n            magnetURI: finalMagnetURI || item.magnetURI\n          }}\n          index={index}\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          key={`${id}-${index}`}\n        />\n      );\n    }\n    if (Common.isEmbeddedStream(item)) {\n      if (item.playbackMagnet) {\n        return (\n          <Video\n            item={{\n              ...item,\n              magnetURI: item.playbackMagnet\n            }}\n            index={index}\n            tipCounter={tipCounter}\n            tipValue={tipValue}\n            key={`${id}-${index}`}\n          />\n        );\n      }\n      return (\n        <Stream\n          id={key}\n          item={{\n            ...item,\n            magnetURI: finalMagnetURI || item.magnetURI\n          }}\n          index={index}\n          postId={id}\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          key={`${id}-${index}`}\n          hideRibbon={undefined}\n          width={undefined}\n        />\n      );\n    }\n\n    return null;\n  };\n\n  const nextSlide = useCallback(() => {\n    if (!carouselAPI) return;\n\n    if (carouselAPI.canScrollNext()) {\n      carouselAPI.scrollNext();\n    }\n  }, [carouselAPI]);\n\n  const prevSlide = useCallback(() => {\n    if (!carouselAPI) return;\n\n    if (carouselAPI.canScrollPrev()) {\n      carouselAPI.scrollPrev();\n    }\n  }, [carouselAPI]);\n\n  const handleUserKeyDown = useCallback(\n    e => {\n      if (sliderLength === 0) return;\n      const { key } = e;\n\n      if (key === \"ArrowRight\") {\n        nextSlide();\n      }\n\n      if (key === \"ArrowLeft\") {\n        prevSlide();\n      }\n    },\n    [sliderLength, prevSlide, nextSlide]\n  );\n\n  const updateActiveSlide = useCallback(() => {\n    setActiveSlide(carouselAPI.selectedScrollSnap());\n  }, [carouselAPI, setActiveSlide]);\n\n  useEffect(() => {\n    if (!carouselAPI) return;\n\n    carouselAPI.on(\"scroll\", updateActiveSlide);\n    setSliderLength(carouselAPI.scrollSnapList().length);\n    window.addEventListener(\"keydown\", handleUserKeyDown);\n\n    return () => {\n      window.removeEventListener(\"keydown\", handleUserKeyDown);\n      carouselAPI.off(\"scroll\", updateActiveSlide);\n    };\n  }, [carouselAPI, sliderLength, handleUserKeyDown, updateActiveSlide]);\n\n  const tipPost = useCallback(() => {\n    if (!isOnlineNode) {\n      return;\n    }\n\n    openTipModal({\n      targetType: \"post\",\n      postID: id,\n      publicKey\n    });\n  }, [id, isOnlineNode, openTipModal, publicKey]);\n\n  const unlockPost = useCallback(() => {\n    if (!isOnlineNode) {\n      return;\n    }\n\n    openUnlockModal({\n      targetType: \"unlock\",\n      postID: id,\n      publicKey\n    });\n  }, [id, isOnlineNode, openUnlockModal, publicKey]);\n\n  const deletePost = useCallback(() => {\n    openDeleteModal({ id, shared: false });\n  }, [id, openDeleteModal]);\n\n  const sharePost = useCallback(() => {\n    if (!authenticated) {\n      const url = `https://${window.location.host}/${publicKey}/post/${id}`;\n\n      if (navigator.share) {\n        navigator.share({\n          text: `Check out ${author.displayName}'s post on Lightning.Page!`,\n          url\n        });\n        return;\n      }\n\n      navigator.clipboard.writeText(url);\n      return;\n    }\n\n    openShareModal({\n      targetType: \"share\",\n      postID: id,\n      publicKey\n    });\n  }, [authenticated, openShareModal, id, publicKey, author.displayName]);\n\n  useEffect(() => {\n    try {\n      Tooltip.rebuild();\n    } catch (e) {\n      console.log(`Error inside <Post />: `, e);\n    }\n  }, []);\n\n  useLayoutEffect(() => {\n    if (mediaAttached) {\n      attachMedia([post], false);\n    }\n\n    if (mediaDetached) {\n      Object.entries(post.contentItems).map(([key, item]) => {\n        if (\"magnetURI\" in item) {\n          detachTorrent({\n            magnetURI: item.magnetURI\n          });\n        }\n      });\n    }\n  }, [mediaAttached, mediaDetached, post]);\n\n  const readableLiveStatus: Record<Common.LiveStatus, string> = {\n    live: \"Is Live\",\n    waiting: \"Waiting\",\n    wasLive: \"Was Live\"\n  };\n\n  return (\n    <div className=\"post\" ref={observe}>\n      <div className=\"head\">\n        <div className=\"user\">\n          <ShockAvatar height={50} publicKey={publicKey} />\n\n          <Pad amt={10} insideRow />\n\n          <div className=\"details\">\n            <div className=\"username\">\n              <Link to={`/otherUser/${publicKey}`}>{author.displayName}</Link>\n              {liveStatus && (\n                <p className=\"liveStatus\">\n                  {readableLiveStatus[liveStatus]}\n                  <i\n                    className={`fas fa-circle liveStatusIcon ${\n                      liveStatus === \"live\" ? \"liveIcon\" : \"\"\n                    }`}\n                  ></i>\n                  {liveStatus === \"live\" && (\n                    <span> | {viewersCounter} watching</span>\n                  )}\n                </p>\n              )}\n            </div>\n            <p>{DateTime.fromMillis(post.date).toRelative()}</p>\n          </div>\n        </div>\n        {openDeleteModal && (\n          <i className=\"fas fa-trash trash-icon\" onClick={deletePost}></i>\n        )}\n      </div>\n\n      <div className=\"content\">\n        {getTextContent().map(parseContent)}\n        <div className=\"media-content-carousel\">\n          {sliderLength > 1 ? (\n            <div className=\"media-carousel-controls-container\">\n              <div\n                className=\"media-carousel-arrow fas fa-angle-left\"\n                onClick={prevSlide}\n              ></div>\n              <div className=\"media-carousel-pages\">\n                {Array.from({ length: sliderLength }).map((_, key) => (\n                  <div\n                    // TODO: Get the actual ID here. However posts can't be\n                    // edited so index is stable.\n                    key={key}\n                    className={classNames({\n                      \"media-carousel-page\": true,\n                      \"active-carousel-page\": activeSlide === key\n                    })}\n                    onClick={() => carouselAPI?.scrollTo(key)}\n                  ></div>\n                ))}\n              </div>\n              <div\n                className=\"media-carousel-arrow fas fa-angle-right\"\n                onClick={nextSlide}\n              ></div>\n            </div>\n          ) : null}\n          <div className=\"media-content-root\" ref={carouselRef}>\n            <div className=\"media-content-container\">\n              {getMediaContent().map(parseContent)}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"actions\">\n        <div></div>\n        <div\n          className=\"icon-tip-btn\"\n          data-tip={isPrivate ? \"Unlock this post\" : \"Tip this post\"}\n          onClick={isPrivate ? unlockPost : tipPost}\n        >\n          <div className=\"tip-icon icon-thin-feed\"></div>\n        </div>\n        {openShareModal && (\n          <div className=\"icon-tip-btn\" data-tip=\"share\" onClick={sharePost}>\n            <img\n              alt=\"Share this post\"\n              src={ShareIcon}\n              style={{ color: \"#4285b9\", marginLeft: \"auto\" }}\n            />\n          </div>\n        )}\n        {!openShareModal && <div></div>}\n      </div>\n    </div>\n  );\n};\n\nexport default memo(Post);\n"],"sourceRoot":""}