{"version":3,"sources":["common/Post/components/Image/index.js","utils/Cache.js","utils/Promise.js","utils/Torrents.js","common/Post/components/Video/index.js","images/share.svg","common/Post/index.tsx"],"names":["Image","id","item","index","postId","tipValue","tipCounter","hideRibbon","width","disableZoom","style","useState","zoomed","setZoomed","zoomLoaded","setZoomLoaded","previewVisible","setPreviewVisible","animationTimer","setAnimationTimer","handleZoomChange","useCallback","value","clearTimeout","timer","setTimeout","contentURL","decodeURIComponent","magnetURI","replace","mainImageStyle","opacity","imgNode","className","alt","data-torrent","data-file-key","src","onLoad","display","isZoomed","onZoomChange","overlayBgColorStart","overlayBgColorEnd","memo","getCachedFile","fileName","a","FileCache","_init","Promise","resolve","reject","init","then","console","log","persist","status","persistent","load","cachedFile","createURL","warn","renderCachedFile","fileURL","selector","elements","document","querySelectorAll","length","forEach","element","muted","autoplay","saveFile","buffer","save","runSerial","tasks","result","task","supportedFileTypes","formats","options","_getFileType","Object","values","reduce","supportedFormats","fileType","file","extension","name","split","slice","entries","filter","includes","supportedFileType","webTorrentClient","initializeClient","WebTorrent","default","showDynamicThumbnail","thumbnailFile","thumbnailFileType","thumbnailTarget","dynamicThumbnailTarget","querySelector","classList","add","remove","getCacheId","key","renderTorrent","type","torrentMode","torrent","target","torrentElements","torrentElement","contains","format","toLowerCase","endsWith","compatibleURL","setAttribute","renderTo","getThumbnailRenderer","thumbnailFileNames","getCacheFileName","thumbnails","sanitizedName","join","thumbnailName","thumbnailIndex","indexOf","cachedThumbnail","attachMedia","posts","all","map","post","contentItems","supportedItems","get","files","match","renderThumbnail","destroy","on","getBlob","err","blob","dataset","played","getAttribute","torrentTasks","torrents","detachTorrent","Video","videoRef","useRef","playing","setPlaying","observe","useInView","trackVisibility","delay","onEnter","current","play","onLeave","pause","togglePlayingStatus","updatedPlaying","videoHeight","useMemo","CSS","supports","aspectRatio","height","onPause","readyState","ref","classNames","onClick","data-played","controls","TipRibbon","Post","publicKey","openTipModal","openUnlockModal","openDeleteModal","undefined","openShareModal","_","dispatch","Store","unlockedContent","content","authenticated","auth","useEmblaCarousel","slidesToScroll","align","carouselRef","carouselAPI","author","React","tips","sum","sliderLength","setSliderLength","activeSlide","setActiveSlide","isPrivate","setIsPrivate","mediaAttached","setMediaAttached","mediaDetached","setMediaDetached","isOnlineNode","useEffect","subPostContent","subPostTips","liveStatus","stream","find","viewersCounter","getMediaContent","k","e","path","parseContent","text","finalMagnetURI","cached","Common","playbackMagnet","Stream","nextSlide","canScrollNext","scrollNext","prevSlide","canScrollPrev","scrollPrev","handleUserKeyDown","updateActiveSlide","selectedScrollSnap","scrollSnapList","window","addEventListener","removeEventListener","off","tipPost","targetType","postID","unlockPost","deletePost","shared","sharePost","url","location","host","navigator","share","displayName","clipboard","writeText","Tooltip","rebuild","useLayoutEffect","ShockAvatar","Pad","amt","insideRow","to","live","waiting","wasLive","DateTime","fromMillis","date","toRelative","getTextContent","Array","from","scrollTo","data-tip","ShareIcon","color","marginLeft"],"mappings":"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","file":"static/js/32.2c7439b9.chunk.js","sourcesContent":["import React, { memo, useState, useCallback } from \"react\";\nimport { Controlled as ControlledZoom } from \"react-medium-image-zoom\";\nimport TipRibbon from \"../TipRibbon\";\nimport \"react-medium-image-zoom/dist/styles.css\";\nimport \"./css/index.scoped.css\";\n\nconst IMAGE_TRANSITION_MS = 200;\n\nconst Image = ({\n  id = \"\",\n  item,\n  index = 0,\n  postId = \"\",\n  tipValue = 0,\n  tipCounter = 0,\n  hideRibbon = false,\n  width = null,\n  disableZoom = false,\n  style = /** @type {import('react').CSSProperties} */ ({})\n}) => {\n  const [zoomed, setZoomed] = useState(false);\n  const [zoomLoaded, setZoomLoaded] = useState(false);\n  const [previewVisible, setPreviewVisible] = useState(true);\n  const [animationTimer, setAnimationTimer] = useState(null);\n\n  const handleZoomChange = useCallback(\n    value => {\n      clearTimeout(animationTimer);\n      setZoomed(value);\n      if (!value && zoomLoaded) {\n        setZoomLoaded(false);\n        const timer = setTimeout(() => {\n          setPreviewVisible(true);\n        }, IMAGE_TRANSITION_MS);\n        setAnimationTimer(timer);\n      }\n\n      if (value) {\n        setPreviewVisible(false);\n      }\n    },\n    [\n      animationTimer,\n      zoomLoaded,\n      setZoomed,\n      setZoomLoaded,\n      setPreviewVisible,\n      setAnimationTimer\n    ]\n  );\n\n  const contentURL = decodeURIComponent(\n    item.magnetURI.replace(/.*(ws=)/gi, \"\")\n  );\n  const mainImageStyle = { ...style, opacity: previewVisible ? 1 : 0 };\n  if (width) {\n    mainImageStyle.width = width;\n  }\n\n  const imgNode = (\n    <>\n      <img\n        className={`image torrent-img torrent-img-${postId}-${id}`}\n        alt=\"Post Media\"\n        data-torrent={item.magnetURI}\n        data-file-key={index}\n        style={mainImageStyle}\n        src={contentURL}\n      />\n      <img\n        className={`image enlarged-img enlarged-img-${postId}-${id}`}\n        alt=\"Post Media\"\n        data-file-key={index}\n        onLoad={() => {\n          setZoomLoaded(true);\n        }}\n        style={{\n          opacity: zoomed ? 1 : 0,\n          display: zoomed ? \"block\" : \"none\"\n        }}\n        src={contentURL}\n      />\n      {!hideRibbon && (\n        <TipRibbon\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          zoomed={zoomed}\n        />\n      )}\n    </>\n  );\n\n  return (\n    <div className=\"media-container\">\n      {disableZoom ? (\n        imgNode\n      ) : (\n        <ControlledZoom\n          isZoomed={zoomed}\n          onZoomChange={handleZoomChange}\n          overlayBgColorStart=\"#16191c00\"\n          overlayBgColorEnd=\"#16191c\"\n        >\n          {imgNode}\n        </ControlledZoom>\n      )}\n    </div>\n  );\n};\n\nexport default memo(Image);\n","import FileCache from \"browser-file-storage\";\n\nexport const DB_NAME = \"ShockWalletStore\";\n\nexport const init = () =>\n  new Promise((resolve, reject) => {\n    FileCache.init(DB_NAME)\n      .then(() => {\n        console.log(\"File cache initialized!\");\n        return FileCache.persist();\n      })\n      .then(status => {\n        if (status.persistent) {\n          resolve(status);\n        } else {\n          reject(status);\n        }\n      });\n  });\n\nexport const getCachedFile = async fileName => {\n  try {\n    if (!FileCache._init) {\n      await init();\n    }\n\n    const cachedFile = await FileCache.load(fileName);\n    return cachedFile.createURL();\n  } catch (err) {\n    console.warn(err);\n    return false;\n  }\n};\n\nexport const renderCachedFile = (fileURL, selector) => {\n  const elements = document.querySelectorAll(selector);\n  if (elements && elements.length) {\n    elements.forEach(element => {\n      if (!element.src) {\n        element.src = fileURL;\n        element.muted = true;\n        element.autoplay = false;\n      }\n    });\n  }\n  return !!elements?.length;\n};\n\nexport const saveFile = (fileName, buffer) => {\n  return FileCache.save(fileName, buffer);\n};\n","export const runSerial = tasks => {\n  let result = Promise.resolve();\n  tasks.forEach(task => {\n    result = result.then(() => task());\n  });\n  return result;\n};\n","import { getCachedFile, renderCachedFile, saveFile } from \"./Cache\";\nimport { runSerial } from \"./Promise\";\n\nexport const supportedFileTypes = {\n  \"video/embedded\": {\n    formats: [\"mp4\", \"webm\"],\n    element: \"video\",\n    options: {\n      autoplay: false,\n      muted: true\n    }\n  },\n  \"image/embedded\": {\n    formats: [\"jpg\", \"png\", \"webp\", \"jpeg\"],\n    element: \"img\",\n    options: {}\n  }\n};\n\nexport const supportedFormats = Object.values(supportedFileTypes).reduce(\n  (supportedFormats, fileType) => [...supportedFormats, ...fileType.formats],\n  []\n);\n\nconst _getFileType = file => {\n  if (!file) {\n    return null;\n  }\n\n  const extension = file.name?.split(\".\")?.slice(-1)[0];\n  const [supportedFileType] = Object.entries(supportedFileTypes).filter(\n    ([type, options]) => options.formats.includes(extension)\n  );\n\n  if (supportedFileType) {\n    const [name, fileType] = supportedFileType;\n    return {\n      name,\n      ...fileType\n    };\n  }\n\n  return null;\n};\n\nexport let webTorrentClient = null;\n\nexport const initializeClient = async () => {\n  if (!webTorrentClient) {\n    const WebTorrent = await import(\"webtorrent\");\n    webTorrentClient = new WebTorrent.default();\n  }\n\n  return webTorrentClient;\n};\n\nconst showDynamicThumbnail = ({ thumbnailFile, fileType, item }) => {\n  const thumbnailFileType = _getFileType(thumbnailFile);\n  const thumbnailTarget = `${\n    thumbnailFileType?.element ?? \"img\"\n  }[data-torrent=\"${item.magnetURI}\"]`;\n  const dynamicThumbnailTarget = `.dynamic-thumbnail[data-torrent=\"${item.magnetURI}\"]`;\n\n  if (!thumbnailFile && fileType.element === \"video\") {\n    document.querySelector(thumbnailTarget)?.classList.add(\"hidden\");\n    document.querySelector(dynamicThumbnailTarget)?.classList.remove(\"hidden\");\n  }\n};\n\nconst getCacheId =\n  ({ id, key }) =>\n  file =>\n    `${id}-${key}-${file.name}`;\n\nconst renderTorrent = ({ file, type, torrentMode, torrent }) => {\n  const element = type.element;\n  const target = `${element}[data-torrent=\"${torrent.magnetURI}\"]`;\n  const torrentElements = document.querySelectorAll(target);\n  console.log(\"Torrent Elements:\", torrentElements);\n  torrentElements.forEach(torrentElement => {\n    // Don't render hidden videos\n    if (torrentElement.classList.contains(\"hidden\")) {\n      return;\n    }\n    const contentURL = decodeURIComponent(\n      torrent.magnetURI.replace(/.*(ws=)/gi, \"\")\n    );\n    const [compatibleURL] = type.formats.filter(format =>\n      contentURL.toLowerCase().endsWith(`.${format.toLowerCase()}`)\n    );\n\n    if (torrentMode || !compatibleURL) {\n      file.renderTo(torrentElement, type.options);\n      return;\n    }\n\n    torrentElement.setAttribute(\"src\", contentURL);\n  });\n};\n\nexport const isURLCompatible = ({ url, type = \"video/embedded\" }) => {\n  const fileType = supportedFileTypes[type];\n  const [compatibleURL] = fileType.formats.filter(format =>\n    url.toLowerCase().endsWith(`.${format.toLowerCase()}`)\n  );\n\n  return !!compatibleURL;\n};\n\nconst getThumbnailRenderer =\n  ({ thumbnailFileNames, getCacheFileName, torrentMode }) =>\n  async ({ fileName, thumbnails, item, fileType }) => {\n    const sanitizedName = fileName.split(\".\").slice(0, -1).join(\".\");\n    const thumbnailName = `${sanitizedName}-thumb`;\n    const thumbnailIndex = thumbnailFileNames.indexOf(thumbnailName);\n    const thumbnailFile = thumbnails[thumbnailIndex];\n    const thumbnailFileType = thumbnailFile\n      ? _getFileType(thumbnailFile)\n      : null;\n    const thumbnailTarget = `${\n      thumbnailFileType?.element ?? \"img\"\n    }[data-torrent=\"${item.magnetURI}\"]`;\n\n    if (fileType.element === \"video\" && thumbnailFile) {\n      const cachedThumbnail = await getCachedFile(\n        getCacheFileName(thumbnailFile)\n      );\n\n      document.querySelector(thumbnailTarget)?.classList.remove(\"hidden\");\n\n      if (cachedThumbnail) {\n        renderCachedFile(cachedThumbnail, thumbnailTarget);\n        return;\n      }\n\n      renderTorrent({\n        file: thumbnailFile,\n        type: thumbnailFileType,\n        torrentMode,\n        torrent: item\n      });\n\n      return;\n    }\n\n    if (fileType.element === \"video\" && !thumbnailFile) {\n      showDynamicThumbnail({\n        thumbnailFile,\n        fileType,\n        item\n      });\n\n      return;\n    }\n\n    return {\n      thumbnailFile\n    };\n  };\n\nexport const attachMedia = async (posts = [], torrentMode = true) => {\n  const torrentTasks = await Promise.all(\n    posts.map(async post => {\n      const { contentItems, id } = post;\n      const supportedItems = Object.entries(contentItems).filter(\n        ([, item]) => supportedFileTypes[item.type]\n      );\n\n      if (!supportedItems) {\n        return [];\n      }\n\n      const webTorrentClient = await initializeClient();\n\n      return supportedItems.map(\n        ([key, item]) =>\n          () =>\n            new Promise(resolve => {\n              const getCacheFileName = getCacheId({ id, key });\n              const torrentExists = webTorrentClient.get(item.magnetURI);\n\n              if (torrentExists) {\n                resolve(true);\n                return;\n              }\n\n              webTorrentClient.add(item.magnetURI, async torrent => {\n                // Proceed to the next torrent in queue\n                resolve(true);\n\n                const files = torrent.files.filter(file => {\n                  const extension = file.name?.split(\".\")?.slice(-1)[0];\n                  const supportedFileType = Object.values(\n                    supportedFileTypes\n                  ).filter(options => options.formats.includes(extension))[0];\n                  if (supportedFileType) {\n                    const fileType = supportedFileType;\n                    const matched = fileType.formats.includes(extension);\n                    return matched;\n                  }\n                  return false;\n                });\n\n                const thumbnails = files.filter(file =>\n                  file.name.match(/-thumb\\.([\\w\\d]){2,4}$/gi)\n                );\n                const thumbnailFileNames = thumbnails.map(file =>\n                  file.name.replace(/\\.([\\w\\d]){2,4}$/gi, \"\")\n                );\n                const renderThumbnail = getThumbnailRenderer({\n                  getCacheFileName,\n                  thumbnailFileNames,\n                  torrentMode\n                });\n\n                files.map(async file => {\n                  // Skip thumbnails\n                  if (thumbnailFileNames.includes(file.name)) {\n                    return;\n                  }\n\n                  const fileType = _getFileType(file);\n\n                  if (!fileType) {\n                    return;\n                  }\n\n                  const fileName = getCacheFileName(file);\n\n                  const element = fileType.element;\n                  const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n                  const cachedFile = await getCachedFile(fileName);\n\n                  renderThumbnail({\n                    fileName: file.name,\n                    thumbnails,\n                    fileType,\n                    item\n                  });\n\n                  if (cachedFile) {\n                    const torrent = webTorrentClient.get(item.magnetURI);\n\n                    if (torrent) {\n                      torrent.destroy();\n                    }\n\n                    renderCachedFile(cachedFile, target);\n                    return;\n                  }\n\n                  renderTorrent({\n                    file,\n                    type: fileType,\n                    torrentMode,\n                    torrent: item\n                  });\n                });\n\n                torrent.on(\"done\", () => {\n                  files.map(file => {\n                    const fileType = _getFileType(file);\n                    const fileName = getCacheFileName(file);\n                    const element = fileType.element;\n                    const target = `${element}.torrent-video[data-torrent=\"${item.magnetURI}\"]`;\n\n                    file.getBlob(async (err, blob) => {\n                      if (err) {\n                        console.warn(err);\n                        return;\n                      }\n\n                      console.log(\"Caching loaded file...\", fileName, blob);\n                      await saveFile(fileName, blob);\n                      const element = document.querySelector(target);\n                      if (\n                        element?.dataset.played === \"false\" &&\n                        !element?.getAttribute(\"src\")\n                      ) {\n                        const cachedFile = await getCachedFile(fileName);\n                        renderCachedFile(cachedFile, target);\n                      }\n                    });\n                  });\n                });\n              });\n            })\n      );\n    })\n  );\n  const contentItems = torrentTasks.reduce(\n    (torrents, contentItems) => [...torrents, ...contentItems],\n    []\n  );\n\n  runSerial(contentItems);\n};\n\nexport const detachTorrent = async ({ magnetURI }) => {\n  const webTorrentClient = await initializeClient();\n  const torrent = webTorrentClient.get(magnetURI);\n\n  if (torrent) {\n    torrent.destroy();\n    return true;\n  }\n\n  return false;\n};\n","import classNames from \"classnames\";\nimport { memo, useCallback, useMemo, useRef, useState } from \"react\";\nimport useInView from \"react-cool-inview\";\nimport TipRibbon from \"../TipRibbon\";\nimport \"./css/index.scoped.css\";\n\nconst Video = ({\n  item,\n  index = 0,\n  tipValue = 0,\n  tipCounter = 0,\n  hideRibbon = false\n}) => {\n  const videoRef = useRef(null);\n  const [playing, setPlaying] = useState(false);\n  const { observe } = useInView({\n    trackVisibility: false,\n    delay: 100,\n    onEnter: () => {\n      if (videoRef.current) {\n        setPlaying(true);\n        videoRef.current.play();\n      }\n    },\n    onLeave: () => {\n      if (!videoRef.current) {\n        return;\n      }\n\n      setPlaying(false);\n      videoRef.current.pause();\n    }\n  });\n\n  const togglePlayingStatus = useCallback(() => {\n    const updatedPlaying = !playing;\n    setPlaying(updatedPlaying);\n    if (videoRef.current) {\n      if (!updatedPlaying) {\n        videoRef.current.pause();\n        return;\n      }\n\n      console.log(\"Playing video\", updatedPlaying);\n      videoRef.current.play();\n    }\n  }, [playing]);\n\n  const videoHeight = useMemo(() => {\n    if (CSS.supports(\"aspect-ratio: 16 / 9\")) {\n      return {\n        aspectRatio: \"16 / 9\"\n      };\n    }\n\n    return {\n      height: 400\n    };\n  }, []);\n\n  const onPause = useCallback(() => {\n    if (videoRef.current?.readyState === 4) {\n      setPlaying(false);\n    }\n  }, [videoRef]);\n\n  return (\n    <div className=\"media-container\" ref={observe}>\n      <div className=\"video-container\" style={videoHeight}>\n        <div\n          className={classNames({\n            \"thumbnail-container\": true,\n            \"video-hidden\": playing\n          })}\n          onClick={togglePlayingStatus}\n        >\n          <div className=\"play-btn\">\n            <i className=\"fas fa-play\" />\n          </div>\n          <img\n            className=\"video-thumbnail hidden\"\n            data-torrent={item.magnetURI}\n            data-file-key={index}\n            alt=\"Video thumbnail\"\n          />\n          <video\n            className=\"dynamic-thumbnail hidden\"\n            data-torrent={item.magnetURI}\n            data-file-key={index}\n            data-played=\"false\"\n            controls={false}\n            muted\n          />\n        </div>\n        <video\n          className={classNames({\n            \"torrent-video video-js vjs-default-skin\": true,\n            \"video-hidden\": !playing\n          })}\n          data-torrent={item.magnetURI}\n          data-file-key={index}\n          data-played=\"false\"\n          controls\n          ref={videoRef}\n          muted\n          onPause={onPause}\n        />\n        {!hideRibbon && (\n          <TipRibbon tipCounter={tipCounter} tipValue={tipValue} />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default memo(Video);\n","export default __webpack_public_path__ + \"static/media/share.8ed36b2d.svg\";","import React, {\n  memo,\n  useEffect,\n  useState,\n  useCallback,\n  useLayoutEffect\n} from \"react\";\nimport * as Common from \"shock-common\";\nimport { Link } from \"react-router-dom\";\nimport useInView from \"react-cool-inview\";\nimport { useEmblaCarousel } from \"embla-carousel/react\";\nimport Tooltip from \"react-tooltip\";\nimport classNames from \"classnames\";\nimport sum from \"lodash/sum\";\nimport { DateTime } from \"luxon\";\n\nimport * as Store from \"../../store\";\nimport { attachMedia, detachTorrent } from \"../../utils/Torrents\";\nimport { subPostContent, subPostTips } from \"../../actions/FeedActions\";\n\nimport Video from \"./components/Video\";\nimport Image from \"./components/Image\";\nimport Stream from \"./components/Stream\";\nimport ShockAvatar from \"../ShockAvatar\";\nimport Pad from \"../Pad\";\n\nimport ShareIcon from \"../../images/share.svg\";\nimport \"./css/index.scoped.css\";\n\nconst Post = ({\n  id,\n  publicKey,\n  openTipModal,\n  openUnlockModal,\n  openDeleteModal = undefined,\n  openShareModal = _ => {}\n}) => {\n  const dispatch = Store.useDispatch();\n  const unlockedContent = Store.useSelector(\n    ({ content }) => content.unlockedContent\n  );\n  const authenticated = Store.useSelector(({ auth }) => auth.authenticated);\n  const [carouselRef, carouselAPI] = useEmblaCarousel({\n    slidesToScroll: 1,\n    align: \"center\"\n  });\n  const author = Store.useSelector(Store.selectUser(publicKey));\n  const post = Store.useSelector(Store.selectSinglePost(publicKey, id));\n  const [tipCounter, tipValue] = React.useMemo(() => {\n    const tips = Object.values(\n      post.tips ||\n        {} /* cached data from previous app version won't have the tips object */\n    );\n\n    return [tips.length, sum(tips)];\n  }, [post]);\n\n  const [sliderLength, setSliderLength] = useState(0);\n  const [activeSlide, setActiveSlide] = useState(0);\n  const [isPrivate, setIsPrivate] = useState(false);\n  // Track Enter/Leave only once\n  const [mediaAttached, setMediaAttached] = useState(false);\n  const [mediaDetached, setMediaDetached] = useState(false);\n  const { observe } = useInView({\n    trackVisibility: false,\n    delay: 100,\n    onEnter: () => {\n      setMediaAttached(true);\n    },\n    onLeave: () => {\n      setMediaDetached(true);\n    }\n  });\n\n  const isOnlineNode = /*Utils.isOnline(\n    Store.useSelector(Store.selectUser(publicKey)).lastSeenApp\n  );*/ true;\n\n  useEffect(() => {\n    const subscription = dispatch(subPostContent(publicKey, id));\n    return subscription;\n  }, [dispatch, id, publicKey]);\n\n  useEffect(() => {\n    const subscription = dispatch(subPostTips(publicKey, id));\n    return subscription;\n  }, [dispatch, id, publicKey]);\n\n  const liveStatus = React.useMemo<Common.LiveStatus | null>(() => {\n    const stream = Object.values(post.contentItems ?? {}).find(\n      item => item.type === \"stream/embedded\"\n    ) as Common.EmbeddedStream;\n\n    if (stream) {\n      return stream.liveStatus;\n    }\n\n    return null;\n  }, [post.contentItems]);\n\n  const viewersCounter = React.useMemo<number | null>(() => {\n    const stream = Object.values(post.contentItems ?? {}).find(\n      item => item.type === \"stream/embedded\"\n    ) as Common.EmbeddedStream;\n\n    if (stream && stream.liveStatus === \"live\") {\n      return stream.viewersCounter;\n    }\n\n    return null;\n  }, [post.contentItems]);\n\n  const getMediaContent = useCallback(() => {\n    return Object.entries(post.contentItems ?? {}).filter(\n      ([_, item]) => item.type !== \"text/paragraph\"\n    );\n  }, [post.contentItems]);\n\n  const getTextContent = () => {\n    return Object.entries(post.contentItems ?? {}).filter(\n      ([_, item]) => item.type === \"text/paragraph\"\n    );\n  };\n\n  useEffect(() => {\n    getMediaContent().forEach(([k, e]) => {\n      const path = `${publicKey}>posts>${k}`;\n      // @ts-expect-error\n      if (e.isPrivate && !unlockedContent[path]) {\n        setIsPrivate(true);\n      }\n    });\n  }, [getMediaContent, publicKey, unlockedContent]);\n\n  const parseContent = ([key, item]: [string, Common.ContentItem], index) => {\n    if (item.type === \"text/paragraph\") {\n      return <p key={key}>{item.text}</p>;\n    }\n\n    let finalMagnetURI = \"\";\n    if (item.isPrivate) {\n      const path = `${publicKey}>posts>${id}`;\n      const cached = unlockedContent[path];\n      if (cached) {\n        finalMagnetURI = cached;\n      } else {\n        return (\n          <div key={key}>\n            <i className=\"fas fa-lock fa-10x\"></i>\n          </div>\n        );\n      }\n    }\n\n    if (item.type === \"image/embedded\") {\n      return (\n        <Image\n          id={key}\n          item={{\n            ...item,\n            magnetURI: finalMagnetURI || item.magnetURI\n          }}\n          index={index}\n          postId={id}\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          key={`${id}-${index}`}\n          hideRibbon={undefined}\n          width={undefined}\n        />\n      );\n    }\n\n    if (item.type === \"video/embedded\") {\n      return (\n        <Video\n          item={{\n            ...item,\n            magnetURI: finalMagnetURI || item.magnetURI\n          }}\n          index={index}\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          key={`${id}-${index}`}\n        />\n      );\n    }\n    if (Common.isEmbeddedStream(item)) {\n      if (item.playbackMagnet) {\n        return (\n          <Video\n            item={{\n              ...item,\n              magnetURI: item.playbackMagnet\n            }}\n            index={index}\n            tipCounter={tipCounter}\n            tipValue={tipValue}\n            key={`${id}-${index}`}\n          />\n        );\n      }\n      return (\n        <Stream\n          id={key}\n          item={{\n            ...item,\n            magnetURI: finalMagnetURI || item.magnetURI\n          }}\n          index={index}\n          postId={id}\n          tipCounter={tipCounter}\n          tipValue={tipValue}\n          key={`${id}-${index}`}\n          hideRibbon={undefined}\n          width={undefined}\n        />\n      );\n    }\n\n    return null;\n  };\n\n  const nextSlide = useCallback(() => {\n    if (!carouselAPI) return;\n\n    if (carouselAPI.canScrollNext()) {\n      carouselAPI.scrollNext();\n    }\n  }, [carouselAPI]);\n\n  const prevSlide = useCallback(() => {\n    if (!carouselAPI) return;\n\n    if (carouselAPI.canScrollPrev()) {\n      carouselAPI.scrollPrev();\n    }\n  }, [carouselAPI]);\n\n  const handleUserKeyDown = useCallback(\n    e => {\n      if (sliderLength === 0) return;\n      const { key } = e;\n\n      if (key === \"ArrowRight\") {\n        nextSlide();\n      }\n\n      if (key === \"ArrowLeft\") {\n        prevSlide();\n      }\n    },\n    [sliderLength, prevSlide, nextSlide]\n  );\n\n  const updateActiveSlide = useCallback(() => {\n    setActiveSlide(carouselAPI.selectedScrollSnap());\n  }, [carouselAPI, setActiveSlide]);\n\n  useEffect(() => {\n    if (!carouselAPI) return;\n\n    carouselAPI.on(\"scroll\", updateActiveSlide);\n    setSliderLength(carouselAPI.scrollSnapList().length);\n    window.addEventListener(\"keydown\", handleUserKeyDown);\n\n    return () => {\n      window.removeEventListener(\"keydown\", handleUserKeyDown);\n      carouselAPI.off(\"scroll\", updateActiveSlide);\n    };\n  }, [carouselAPI, sliderLength, handleUserKeyDown, updateActiveSlide]);\n\n  const tipPost = useCallback(() => {\n    if (!isOnlineNode) {\n      return;\n    }\n\n    openTipModal({\n      targetType: \"post\",\n      postID: id,\n      publicKey\n    });\n  }, [id, isOnlineNode, openTipModal, publicKey]);\n\n  const unlockPost = useCallback(() => {\n    if (!isOnlineNode) {\n      return;\n    }\n\n    openUnlockModal({\n      targetType: \"unlock\",\n      postID: id,\n      publicKey\n    });\n  }, [id, isOnlineNode, openUnlockModal, publicKey]);\n\n  const deletePost = useCallback(() => {\n    openDeleteModal({ id, shared: false });\n  }, [id, openDeleteModal]);\n\n  const sharePost = useCallback(() => {\n    if (!authenticated) {\n      const url = `https://${window.location.host}/${publicKey}/post/${id}`;\n\n      if (navigator.share) {\n        navigator.share({\n          text: `Check out ${author.displayName}'s post on Lightning.Page!`,\n          url\n        });\n        return;\n      }\n\n      navigator.clipboard.writeText(url);\n      return;\n    }\n\n    openShareModal({\n      targetType: \"share\",\n      postID: id,\n      publicKey\n    });\n  }, [authenticated, openShareModal, id, publicKey, author.displayName]);\n\n  useEffect(() => {\n    try {\n      Tooltip.rebuild();\n    } catch (e) {\n      console.log(`Error inside <Post />: `, e);\n    }\n  }, []);\n\n  useLayoutEffect(() => {\n    if (mediaAttached) {\n      attachMedia([post], false);\n    }\n\n    if (mediaDetached) {\n      Object.entries(post.contentItems).map(([key, item]) => {\n        if (\"magnetURI\" in item) {\n          detachTorrent({\n            magnetURI: item.magnetURI\n          });\n        }\n      });\n    }\n  }, [mediaAttached, mediaDetached, post]);\n\n  const readableLiveStatus: Record<Common.LiveStatus, string> = {\n    live: \"Is Live\",\n    waiting: \"Waiting\",\n    wasLive: \"Was Live\"\n  };\n\n  return (\n    <div className=\"post\" ref={observe}>\n      <div className=\"head\">\n        <div className=\"user\">\n          <ShockAvatar height={50} publicKey={publicKey} />\n\n          <Pad amt={10} insideRow />\n\n          <div className=\"details\">\n            <div className=\"username\">\n              <Link to={`/otherUser/${publicKey}`}>{author.displayName}</Link>\n              {liveStatus && (\n                <p className=\"liveStatus\">\n                  {readableLiveStatus[liveStatus]}\n                  <i\n                    className={`fas fa-circle liveStatusIcon ${\n                      liveStatus === \"live\" ? \"liveIcon\" : \"\"\n                    }`}\n                  ></i>\n                  {liveStatus === \"live\" && (\n                    <span> | {viewersCounter} watching</span>\n                  )}\n                </p>\n              )}\n            </div>\n            <p>{DateTime.fromMillis(post.date).toRelative()}</p>\n          </div>\n        </div>\n        {openDeleteModal && (\n          <i className=\"fas fa-trash trash-icon\" onClick={deletePost}></i>\n        )}\n      </div>\n\n      <div className=\"content\">\n        {getTextContent().map(parseContent)}\n        <div className=\"media-content-carousel\">\n          {sliderLength > 1 ? (\n            <div className=\"media-carousel-controls-container\">\n              <div\n                className=\"media-carousel-arrow fas fa-angle-left\"\n                onClick={prevSlide}\n              ></div>\n              <div className=\"media-carousel-pages\">\n                {Array.from({ length: sliderLength }).map((_, key) => (\n                  <div\n                    // TODO: Get the actual ID here. However posts can't be\n                    // edited so index is stable.\n                    key={key}\n                    className={classNames({\n                      \"media-carousel-page\": true,\n                      \"active-carousel-page\": activeSlide === key\n                    })}\n                    onClick={() => carouselAPI?.scrollTo(key)}\n                  ></div>\n                ))}\n              </div>\n              <div\n                className=\"media-carousel-arrow fas fa-angle-right\"\n                onClick={nextSlide}\n              ></div>\n            </div>\n          ) : null}\n          <div className=\"media-content-root\" ref={carouselRef}>\n            <div className=\"media-content-container\">\n              {getMediaContent().map(parseContent)}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"actions\">\n        <div></div>\n        <div\n          className=\"icon-tip-btn\"\n          data-tip={isPrivate ? \"Unlock this post\" : \"Tip this post\"}\n          onClick={isPrivate ? unlockPost : tipPost}\n        >\n          <div className=\"tip-icon icon-thin-feed\"></div>\n        </div>\n        {openShareModal && (\n          <div className=\"icon-tip-btn\" data-tip=\"share\" onClick={sharePost}>\n            <img\n              alt=\"Share this post\"\n              src={ShareIcon}\n              style={{ color: \"#4285b9\", marginLeft: \"auto\" }}\n            />\n          </div>\n        )}\n        {!openShareModal && <div></div>}\n      </div>\n    </div>\n  );\n};\n\nexport default memo(Post);\n"],"sourceRoot":""}